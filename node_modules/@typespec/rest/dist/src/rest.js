import { $list, createDiagnosticCollector, setTypeSpecNamespace, } from "@typespec/compiler";
import { DefaultRouteProducer, getOperationParameters, getOperationVerb, getRoutePath, getRouteProducer, setRouteProducer, } from "@typespec/http";
import { createStateSymbol, reportDiagnostic } from "./lib.js";
import { getResourceTypeKey } from "./resource.js";
// ----------------- @autoRoute -----------------
function addActionFragment(program, target, pathFragments) {
    var _a;
    // add the action segment, if present
    const defaultSeparator = "/";
    const actionSegment = getActionSegment(program, target);
    if (actionSegment && actionSegment !== "") {
        const actionSeparator = (_a = getActionSeparator(program, target)) !== null && _a !== void 0 ? _a : defaultSeparator;
        pathFragments.push(`${actionSeparator}${actionSegment}`);
    }
}
function addSegmentFragment(program, target, pathFragments) {
    // Don't add the segment prefix if it is meant to be excluded
    // (empty string means exclude the segment)
    const segment = getSegment(program, target);
    if (segment && segment !== "") {
        pathFragments.push(`/${segment}`);
    }
}
// TODO: Make this overridable by libraries
const resourceOperationToVerb = {
    read: "get",
    create: "post",
    createOrUpdate: "patch",
    createOrReplace: "put",
    update: "patch",
    delete: "delete",
    list: "get",
};
function getResourceOperationHttpVerb(program, operation) {
    var _a, _b;
    const resourceOperation = getResourceOperation(program, operation);
    return ((_b = (_a = getOperationVerb(program, operation)) !== null && _a !== void 0 ? _a : (resourceOperation && resourceOperationToVerb[resourceOperation.operation])) !== null && _b !== void 0 ? _b : (getAction(program, operation) || getCollectionAction(program, operation) ? "post" : undefined));
}
function autoRouteProducer(program, operation, parentSegments, overloadBase, options) {
    var _a, _b, _c, _d;
    const diagnostics = createDiagnosticCollector();
    const routePath = (_a = getRoutePath(program, operation)) === null || _a === void 0 ? void 0 : _a.path;
    const segments = [...parentSegments, ...(routePath ? [routePath] : [])];
    const filteredParameters = [];
    const paramOptions = {
        ...((_b = options === null || options === void 0 ? void 0 : options.paramOptions) !== null && _b !== void 0 ? _b : {}),
        verbSelector: getResourceOperationHttpVerb,
    };
    const parameters = diagnostics.pipe(getOperationParameters(program, operation, undefined, [], paramOptions));
    for (const httpParam of parameters.parameters) {
        const { type, param } = httpParam;
        if (type === "path") {
            addSegmentFragment(program, param, segments);
            const filteredParam = (_d = (_c = options.autoRouteOptions) === null || _c === void 0 ? void 0 : _c.routeParamFilter) === null || _d === void 0 ? void 0 : _d.call(_c, operation, param);
            if (filteredParam === null || filteredParam === void 0 ? void 0 : filteredParam.routeParamString) {
                segments.push(`/${filteredParam.routeParamString}`);
                if ((filteredParam === null || filteredParam === void 0 ? void 0 : filteredParam.excludeFromOperationParams) === true) {
                    // Skip the rest of the loop so that we don't add the parameter to the final list
                    continue;
                }
            }
            else {
                // Add the path variable for the parameter
                if (param.type.kind === "String") {
                    segments.push(`/${param.type.value}`);
                    continue; // Skip adding to the parameter list
                }
                else {
                    segments.push(`/{${param.name}}`);
                }
            }
        }
        // Push all usable parameters to the filtered list
        filteredParameters.push(httpParam);
    }
    // Replace the original parameters with filtered set
    parameters.parameters = filteredParameters;
    // Add the operation's own segment if present
    addSegmentFragment(program, operation, segments);
    // Add the operation's action segment if present
    addActionFragment(program, operation, segments);
    return diagnostics.wrap({
        segments,
        parameters: {
            ...parameters,
            parameters: filteredParameters,
        },
    });
}
const autoRouteKey = createStateSymbol("autoRoute");
/**
 * `@autoRoute` enables automatic route generation for an operation or interface.
 *
 * When applied to an operation, it automatically generates the operation's route based on path parameter
 * metadata.  When applied to an interface, it causes all operations under that scope to have
 * auto-generated routes.
 */
export function $autoRoute(context, entity) {
    if (entity.kind === "Operation") {
        setRouteProducer(context.program, entity, autoRouteProducer);
    }
    else {
        for (const [_, op] of entity.operations) {
            // Instantly apply the decorator to the operation
            context.call($autoRoute, op);
            // Manually push the decorator onto the property so that it gets applied
            // to operations which reference the operation with `is`
            op.decorators.push({
                decorator: $autoRoute,
                args: [],
            });
        }
    }
    context.program.stateSet(autoRouteKey).add(entity);
}
export function isAutoRoute(program, entity) {
    return program.stateSet(autoRouteKey).has(entity);
}
// ------------------ @segment ------------------
const segmentsKey = createStateSymbol("segments");
/**
 * `@segment` defines the preceding path segment for a `@path` parameter in auto-generated routes
 *
 * The first argument should be a string that will be inserted into the operation route before the
 * path parameter's name field.
 *
 * `@segment` can only be applied to model properties, operation parameters, or operations.
 */
export function $segment(context, entity, name) {
    context.program.stateMap(segmentsKey).set(entity, name);
}
function getResourceSegment(program, resourceType) {
    // Add path segment for resource type key (if it has one)
    const resourceKey = getResourceTypeKey(program, resourceType);
    return resourceKey
        ? getSegment(program, resourceKey.keyProperty)
        : getSegment(program, resourceType);
}
export function $segmentOf(context, entity, resourceType) {
    if (resourceType.kind === "TemplateParameter") {
        // Skip it, this operation is in a templated interface
        return;
    }
    // Add path segment for resource type key (if it has one)
    const segment = getResourceSegment(context.program, resourceType);
    if (segment) {
        context.call($segment, entity, segment);
    }
}
export function getSegment(program, entity) {
    return program.stateMap(segmentsKey).get(entity);
}
const actionSeparatorKey = createStateSymbol("actionSeparator");
/**
 * `@actionSeparator` defines the separator string that is used to precede the action name
 *  in auto-generated actions.
 *
 * `@actionSeparator` can only be applied to model properties, operation parameters, or operations.
 */
export function $actionSeparator(context, entity, separator) {
    context.program.stateMap(actionSeparatorKey).set(entity, separator);
}
/**
 * @param program the TypeSpec program
 * @param entity the target entity
 * @returns the action separator string
 */
export function getActionSeparator(program, entity) {
    return program.stateMap(actionSeparatorKey).get(entity);
}
/**
 * `@resource` marks a model as a resource type.
 *
 * The first argument should be the name of the collection that the resources
 * belong to.  For example, a resource type `Widget` might have a collection
 * name of `widgets`.
 *
 * `@resource` can only be applied to models.
 */
export function $resource(context, entity, collectionName) {
    // Ensure type has a key property
    const key = getResourceTypeKey(context.program, entity);
    // A resource type must have a key property
    if (!key) {
        reportDiagnostic(context.program, {
            code: "resource-missing-key",
            format: {
                modelName: entity.name,
            },
            target: entity,
        });
        return;
    }
    // Apply the @segment decorator with the collection name
    context.call($segment, key.keyProperty, collectionName);
    // Manually push the decorator onto the property so that it's copyable in KeysOf<T>
    key.keyProperty.decorators.push({
        decorator: $segment,
        args: [{ value: context.program.checker.createLiteralType(collectionName) }],
    });
}
const resourceOperationsKey = createStateSymbol("resourceOperations");
function resourceRouteProducer(program, operation, parentSegments, overloadBase, options) {
    // NOTE: The purpose of this producer is to pass along the behavior of the
    // DefaultRouteProducer while setting the appropriate HTTP verb based on any
    // resource operation decorators that have been applied.  This behavior will
    // be overridden by the `autoRouteProducer` if `autoRoute` is also applied to
    // the same operation.
    var _a;
    // Set the OperationVerbSelector to pick verbs based on resource operation type
    const paramOptions = {
        ...((_a = options === null || options === void 0 ? void 0 : options.paramOptions) !== null && _a !== void 0 ? _a : {}),
        verbSelector: getResourceOperationHttpVerb,
    };
    return DefaultRouteProducer(program, operation, parentSegments, overloadBase, {
        ...options,
        paramOptions,
    });
}
export function setResourceOperation(context, entity, resourceType, operation) {
    if (resourceType.kind === "TemplateParameter") {
        // Skip it, this operation is in a templated interface
        return;
    }
    context.program.stateMap(resourceOperationsKey).set(entity, {
        operation,
        resourceType,
    });
    // Set a custom RouteProducer on the operation if one hasn't already been
    // established yet.  This is intended to translate lifecycle operations to
    // HTTP verbs.
    if (!getRouteProducer(context.program, entity)) {
        setRouteProducer(context.program, entity, resourceRouteProducer);
    }
}
export function getResourceOperation(program, typespecOperation) {
    return program.stateMap(resourceOperationsKey).get(typespecOperation);
}
export function $readsResource(context, entity, resourceType) {
    setResourceOperation(context, entity, resourceType, "read");
}
export function $createsResource(context, entity, resourceType) {
    // Add path segment for resource type key
    context.call($segmentOf, entity, resourceType);
    setResourceOperation(context, entity, resourceType, "create");
}
export function $createsOrReplacesResource(context, entity, resourceType) {
    setResourceOperation(context, entity, resourceType, "createOrReplace");
}
export function $createsOrUpdatesResource(context, entity, resourceType) {
    setResourceOperation(context, entity, resourceType, "createOrUpdate");
}
export function $updatesResource(context, entity, resourceType) {
    setResourceOperation(context, entity, resourceType, "update");
}
export function $deletesResource(context, entity, resourceType) {
    setResourceOperation(context, entity, resourceType, "delete");
}
export function $listsResource(context, entity, resourceType) {
    // Add the @list decorator too so that collection routes are generated correctly
    context.call($list, entity, resourceType);
    // Add path segment for resource type key
    context.call($segmentOf, entity, resourceType);
    setResourceOperation(context, entity, resourceType, "list");
}
function lowerCaseFirstChar(str) {
    return str[0].toLocaleLowerCase() + str.substring(1);
}
function makeActionName(op, name) {
    return lowerCaseFirstChar(name || op.name);
}
const actionsSegmentKey = createStateSymbol("actionSegment");
export function $actionSegment(context, entity, name) {
    context.program.stateMap(actionsSegmentKey).set(entity, name);
}
export function getActionSegment(program, entity) {
    return program.stateMap(actionsSegmentKey).get(entity);
}
const actionsKey = createStateSymbol("actions");
export function $action(context, entity, name) {
    if (name === "") {
        reportDiagnostic(context.program, {
            code: "invalid-action-name",
            target: entity,
        });
        return;
    }
    const action = makeActionName(entity, name);
    context.call($actionSegment, entity, action);
    context.program.stateMap(actionsKey).set(entity, action);
}
export function getAction(program, operation) {
    return program.stateMap(actionsKey).get(operation);
}
const collectionActionsKey = createStateSymbol("collectionActions");
export function $collectionAction(context, entity, resourceType, name) {
    if (resourceType.kind === "TemplateParameter") {
        // Skip it, this operation is in a templated interface
        return;
    }
    // only add the resource portion of the segment
    const segment = getResourceSegment(context.program, resourceType);
    if (segment) {
        context.call($segment, entity, segment);
    }
    const action = makeActionName(entity, name);
    context.call($actionSegment, entity, action);
    context.program.stateMap(collectionActionsKey).set(entity, `${segment}/${action}`);
}
export function getCollectionAction(program, operation) {
    return program.stateMap(collectionActionsKey).get(operation);
}
const resourceLocationsKey = createStateSymbol("resourceLocations");
export function $resourceLocation(context, entity, resourceType) {
    if (resourceType.kind === "TemplateParameter") {
        // Skip it, this operation is in a templated interface
        return;
    }
    context.program.stateMap(resourceLocationsKey).set(entity, resourceType);
}
export function getResourceLocationType(program, entity) {
    return program.stateMap(resourceLocationsKey).get(entity);
}
setTypeSpecNamespace("Private", $resourceLocation, $actionSegment, getActionSegment);
//# sourceMappingURL=rest.js.map