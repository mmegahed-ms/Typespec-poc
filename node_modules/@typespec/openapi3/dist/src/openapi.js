import { compilerAssert, emitFile, getAllTags, getAnyExtensionFromPath, getDiscriminatedUnion, getDiscriminator, getDoc, getFormat, getKnownValues, getMaxItems, getMaxLength, getMaxValue, getMaxValueExclusive, getMinItems, getMinLength, getMinValue, getMinValueExclusive, getNamespaceFullName, getPattern, getPropertyType, getService, getSummary, ignoreDiagnostics, interpolatePath, isDeprecated, isErrorType, isGlobalNamespace, isNeverType, isNullType, isNumericType, isSecret, isStringType, isTemplateDeclaration, isTemplateDeclarationOrInstance, listServices, navigateTypesInNamespace, projectProgram, resolvePath, TwoLevelMap, } from "@typespec/compiler";
import * as http from "@typespec/http";
import { createMetadataInfo, getAuthentication, getHttpService, getStatusCodeDescription, getVisibilitySuffix, isContentTypeHeader, isOverloadSameEndpoint, reportIfNoRoutes, Visibility, } from "@typespec/http";
import { checkDuplicateTypeName, getExtensions, getExternalDocs, getOpenAPITypeName, getParameterKey, isReadonlyProperty, resolveOperationId, shouldInline, } from "@typespec/openapi";
import { buildVersionProjections } from "@typespec/versioning";
import yaml from "js-yaml";
import { getOneOf, getRef } from "./decorators.js";
import { reportDiagnostic } from "./lib.js";
const defaultFileType = "yaml";
const defaultOptions = {
    "new-line": "lf",
    "omit-unreachable-types": false,
};
export async function $onEmit(context) {
    const options = resolveOptions(context);
    const emitter = createOAPIEmitter(context.program, options);
    await emitter.emitOpenAPI();
}
function findFileTypeFromFilename(filename) {
    if (filename === undefined) {
        return defaultFileType;
    }
    switch (getAnyExtensionFromPath(filename)) {
        case ".yaml":
        case ".yml":
            return "yaml";
        case ".json":
            return "json";
        default:
            return defaultFileType;
    }
}
export function resolveOptions(context) {
    var _a, _b;
    const resolvedOptions = { ...defaultOptions, ...context.options };
    const fileType = (_a = resolvedOptions["file-type"]) !== null && _a !== void 0 ? _a : findFileTypeFromFilename(resolvedOptions["output-file"]);
    const outputFile = (_b = resolvedOptions["output-file"]) !== null && _b !== void 0 ? _b : `openapi.{service-name}.{version}.${fileType}`;
    return {
        fileType,
        newLine: resolvedOptions["new-line"],
        omitUnreachableTypes: resolvedOptions["omit-unreachable-types"],
        outputFile: resolvePath(context.emitterOutputDir, outputFile),
    };
}
/**
 * Represents a node that will hold a JSON reference. The value is computed
 * at the end so that we can defer decisions about the name that is
 * referenced.
 */
class Ref {
    toJSON() {
        compilerAssert(this.value, "Reference value never set.");
        return this.value;
    }
}
function createOAPIEmitter(program, options) {
    let root;
    // Get the service namespace string for use in name shortening
    let serviceNamespace;
    let currentPath;
    let currentEndpoint;
    let metadataInfo;
    // Keep a map of all Types+Visibility combinations that were encountered
    // that need schema definitions.
    let pendingSchemas = new TwoLevelMap();
    // Reuse a single ref object per Type+Visibility combination.
    let refs = new TwoLevelMap();
    // Keep track of inline types still in the process of having their schema computed
    // This is used to detect cycles in inline types, which is an
    let inProgressInlineTypes = new Set();
    // Map model properties that represent shared parameters to their parameter
    // definition that will go in #/components/parameters. Inlined parameters do not go in
    // this map.
    let params;
    // Keep track of models that have had properties spread into parameters. We won't
    // consider these unreferenced when emitting unreferenced types.
    let paramModels;
    // De-dupe the per-endpoint tags that will be added into the #/tags
    let tags;
    const typeNameOptions = {
        // shorten type names by removing TypeSpec and service namespace
        namespaceFilter(ns) {
            const name = getNamespaceFullName(ns);
            return name !== serviceNamespace;
        },
    };
    return { emitOpenAPI };
    function initializeEmitter(service, version) {
        var _a, _b, _c;
        const auth = processAuth(service.type);
        root = {
            openapi: "3.0.0",
            info: {
                title: (_a = service.title) !== null && _a !== void 0 ? _a : "(title)",
                version: (_b = version !== null && version !== void 0 ? version : service.version) !== null && _b !== void 0 ? _b : "0000-00-00",
                description: getDoc(program, service.type),
            },
            externalDocs: getExternalDocs(program, service.type),
            tags: [],
            paths: {},
            security: auth === null || auth === void 0 ? void 0 : auth.security,
            components: {
                parameters: {},
                requestBodies: {},
                responses: {},
                schemas: {},
                examples: {},
                securitySchemes: (_c = auth === null || auth === void 0 ? void 0 : auth.securitySchemes) !== null && _c !== void 0 ? _c : {},
            },
        };
        const servers = http.getServers(program, service.type);
        if (servers) {
            root.servers = resolveServers(servers);
        }
        serviceNamespace = getNamespaceFullName(service.type);
        currentPath = root.paths;
        pendingSchemas = new TwoLevelMap();
        refs = new TwoLevelMap();
        metadataInfo = createMetadataInfo(program, {
            canonicalVisibility: Visibility.Read,
            canShareProperty: (p) => isReadonlyProperty(program, p),
        });
        inProgressInlineTypes = new Set();
        params = new Map();
        paramModels = new Set();
        tags = new Set();
    }
    function isValidServerVariableType(program, type) {
        var _a;
        switch (type.kind) {
            case "String":
            case "Union":
            case "Scalar":
                return ignoreDiagnostics(program.checker.isTypeAssignableTo((_a = type.projectionBase) !== null && _a !== void 0 ? _a : type, program.checker.getStdType("string"), type));
            case "Enum":
                for (const member of type.members.values()) {
                    if (member.value && typeof member.value !== "string") {
                        return false;
                    }
                }
                return true;
            default:
                return false;
        }
    }
    function validateValidServerVariable(program, prop) {
        const isValid = isValidServerVariableType(program, prop.type);
        if (!isValid) {
            reportDiagnostic(program, {
                code: "invalid-server-variable",
                format: { propName: prop.name },
                target: prop,
            });
        }
        return isValid;
    }
    function resolveServers(servers) {
        return servers.map((server) => {
            const variables = {};
            for (const [name, prop] of server.parameters) {
                if (!validateValidServerVariable(program, prop)) {
                    continue;
                }
                const variable = {
                    default: prop.default ? getDefaultValue(prop.default) : "",
                    description: getDoc(program, prop),
                };
                if (prop.type.kind === "Enum") {
                    variable.enum = getSchemaForEnum(prop.type).enum;
                }
                else if (prop.type.kind === "Union") {
                    variable.enum = getSchemaForUnion(prop.type, Visibility.Read).enum;
                }
                else if (prop.type.kind === "String") {
                    variable.enum = [prop.type.value];
                }
                attachExtensions(program, prop, variable);
                variables[name] = variable;
            }
            return {
                url: server.url,
                description: server.description,
                variables,
            };
        });
    }
    async function emitOpenAPI() {
        const services = listServices(program);
        if (services.length === 0) {
            services.push({ type: program.getGlobalNamespaceType() });
        }
        for (const service of services) {
            const commonProjections = [
                {
                    projectionName: "target",
                    arguments: ["json"],
                },
            ];
            const originalProgram = program;
            const versions = buildVersionProjections(program, service.type);
            for (const record of versions) {
                const projectedProgram = (program = projectProgram(originalProgram, [
                    ...commonProjections,
                    ...record.projections,
                ]));
                const projectedServiceNs = projectedProgram.projector.projectedTypes.get(service.type);
                await emitOpenAPIFromVersion(projectedServiceNs === projectedProgram.getGlobalNamespaceType()
                    ? { type: projectedProgram.getGlobalNamespaceType() }
                    : getService(program, projectedServiceNs), services.length > 1, record.version);
            }
        }
    }
    function resolveOutputFile(service, multipleService, version) {
        return interpolatePath(options.outputFile, {
            "service-name": multipleService ? getNamespaceFullName(service.type) : undefined,
            version,
        });
    }
    /**
     * Validates that common responses are consistent and returns the minimal set that describes the differences.
     */
    function validateCommonResponses(ops, statusCode) {
        const statusCodeResponses = [];
        for (const op of ops) {
            for (const response of op.responses) {
                if (response.statusCode === statusCode) {
                    statusCodeResponses.push(response);
                }
            }
        }
        const ref = statusCodeResponses[0];
        const sameTypeKind = statusCodeResponses.every((r) => r.type.kind === ref.type.kind);
        const sameTypeValue = statusCodeResponses.every((r) => r.type === ref.type);
        if (sameTypeKind && sameTypeValue) {
            // response is consistent and in all shared operations. Only need one copy.
            return [ref];
        }
        else {
            return statusCodeResponses;
        }
    }
    /**
     * Validates that common bodies are consistent and returns the minimal set that describes the differences.
     */
    function validateCommonBodies(ops) {
        const bodies = ops.map((op) => op.parameters.body);
        const ref = bodies[0];
        const sameOptionality = bodies.every((b) => { var _a, _b; return ((_a = b.parameter) === null || _a === void 0 ? void 0 : _a.optional) === ((_b = ref.parameter) === null || _b === void 0 ? void 0 : _b.optional); });
        const sameTypeKind = bodies.every((b) => { var _a, _b; return ((_a = b.parameter) === null || _a === void 0 ? void 0 : _a.type.kind) === ((_b = ref.parameter) === null || _b === void 0 ? void 0 : _b.type.kind); });
        const sameTypeValue = bodies.every((b) => { var _a, _b; return ((_a = b.parameter) === null || _a === void 0 ? void 0 : _a.type) === ((_b = ref.parameter) === null || _b === void 0 ? void 0 : _b.type); });
        if (sameOptionality && sameTypeKind && sameTypeValue) {
            // param is consistent and in all shared operations. Only need one copy.
            return [ref];
        }
        else {
            return bodies;
        }
    }
    /**
     * Validates that common parameters are consistent and returns the minimal set that describes the differences.
     */
    function validateCommonParameters(ops, name, totalOps) {
        const finalParams = [];
        const commonParams = [];
        for (const op of ops) {
            const param = op.parameters.parameters.find((p) => p.name === name);
            if (param) {
                commonParams.push(param);
            }
        }
        const reference = commonParams[0];
        if (!reference) {
            return [];
        }
        const inAllOps = ops.length === totalOps;
        const sameLocations = commonParams.every((p) => p.type === reference.type);
        const sameOptionality = commonParams.every((p) => p.param.optional === reference.param.optional);
        const sameTypeKind = commonParams.every((p) => p.param.type.kind === reference.param.type.kind);
        const sameTypeValue = commonParams.every((p) => p.param.type === reference.param.type);
        if (inAllOps && sameLocations && sameOptionality && sameTypeKind && sameTypeValue) {
            // param is consistent and in all shared operations. Only need one copy.
            finalParams.push(reference);
        }
        else if (!inAllOps && sameLocations && sameOptionality && sameTypeKind && sameTypeValue) {
            // param is consistent when used, but does not appear in all shared operations. Only need one copy, but it must be optional.
            reference.param.optional = true;
            finalParams.push(reference);
        }
        else if (inAllOps && !(sameLocations && sameOptionality && sameTypeKind)) {
            // param is in all shared operations, but is not consistent. Need multiple copies, which must be optional.
            // exception allowed when the params only differ by their value (e.g. string enum values)
            commonParams.forEach((p) => {
                p.param.optional = true;
            });
            finalParams.push(...commonParams);
        }
        else {
            finalParams.push(...commonParams);
        }
        return finalParams;
    }
    function buildSharedOperations(operations) {
        const results = [];
        const paramMap = new Map();
        const bodyMap = new Map();
        const responseMap = new Map();
        for (const op of operations) {
            // determine which parameters are shared by shared route operations
            for (const param of op.parameters.parameters) {
                if (paramMap.has(param.name)) {
                    paramMap.get(param.name).push(op);
                }
                else {
                    paramMap.set(param.name, [op]);
                }
            }
            // determine which body parameters are shared by shared route operations
            const bodyParam = op.parameters.body;
            if (bodyParam === null || bodyParam === void 0 ? void 0 : bodyParam.parameter) {
                if (bodyMap.has(bodyParam.parameter.name)) {
                    bodyMap.get(bodyParam.parameter.name).push(op);
                }
                else {
                    bodyMap.set(bodyParam.parameter.name, [op]);
                }
            }
            // determine which responses are shared by shared route operations
            for (const response of op.responses) {
                if (responseMap.has(response.statusCode)) {
                    responseMap.get(response.statusCode).push(op);
                }
                else {
                    responseMap.set(response.statusCode, [op]);
                }
            }
        }
        const totalOps = operations.length;
        const shared = {
            kind: "shared",
            operationId: operations.map((op) => resolveOperationId(program, op.operation)).join("_"),
            description: joinOps(operations, getDoc, " "),
            summary: joinOps(operations, getSummary, " "),
            path: operations[0].path,
            verb: operations[0].verb,
            operations: operations.map((op) => op.operation),
            parameters: {
                parameters: [],
            },
            bodies: undefined,
            responses: new Map(),
        };
        for (const [paramName, ops] of paramMap) {
            const commonParams = validateCommonParameters(ops, paramName, totalOps);
            shared.parameters.parameters.push(...commonParams);
        }
        for (const [_, ops] of bodyMap) {
            shared.bodies = validateCommonBodies(ops);
        }
        for (const [statusCode, ops] of responseMap) {
            shared.responses.set(statusCode, validateCommonResponses(ops, statusCode));
        }
        results.push(shared);
        return results;
    }
    /**
     * Groups HttpOperations together if they share the same route.
     */
    function resolveOperations(operations) {
        const result = [];
        const pathMap = new Map();
        operations.forEach((op) => {
            // we don't emit overloads anyhow so emit them from grouping
            if (op.overloading !== undefined && isOverloadSameEndpoint(op)) {
                return;
            }
            const opKey = `${op.verb}|${op.path}`;
            pathMap.has(opKey) ? pathMap.get(opKey).push(op) : pathMap.set(opKey, [op]);
        });
        // now push either the singular HttpOperations or the constructed SharedHttpOperations
        for (const [_, ops] of pathMap) {
            if (ops.length === 1) {
                result.push(ops[0]);
            }
            else {
                const sharedOps = buildSharedOperations(ops);
                for (const op of sharedOps) {
                    result.push(op);
                }
            }
        }
        return result;
    }
    async function emitOpenAPIFromVersion(service, multipleService, version) {
        initializeEmitter(service, version);
        try {
            const httpService = ignoreDiagnostics(getHttpService(program, service.type));
            reportIfNoRoutes(program, httpService.operations);
            for (const op of resolveOperations(httpService.operations)) {
                if (op.kind === "shared") {
                    emitSharedOperation(op);
                }
                else {
                    emitOperation(op);
                }
            }
            emitParameters();
            emitSchemas(service.type);
            emitTags();
            // Clean up empty entries
            if (root.components) {
                for (const elem of Object.keys(root.components)) {
                    if (Object.keys(root.components[elem]).length === 0) {
                        delete root.components[elem];
                    }
                }
            }
            if (!program.compilerOptions.noEmit && !program.hasError()) {
                // Write out the OpenAPI document to the output path
                await emitFile(program, {
                    path: resolveOutputFile(service, multipleService, version),
                    content: serializeDocument(root, options.fileType),
                    newLine: options.newLine,
                });
            }
        }
        catch (err) {
            if (err instanceof ErrorTypeFoundError) {
                // Return early, there must be a parse error if an ErrorType was
                // inserted into the TypeSpec output
                return;
            }
            else {
                throw err;
            }
        }
    }
    function joinOps(operations, func, joinChar) {
        const values = operations
            .map((op) => func(program, op.operation))
            .filter((op) => op !== undefined);
        if (values.length) {
            return values.join(joinChar);
        }
        else {
            return undefined;
        }
    }
    function emitSharedOperation(shared) {
        const { path: fullPath, verb: verb, operations: ops } = shared;
        if (!root.paths[fullPath]) {
            root.paths[fullPath] = {};
        }
        currentPath = root.paths[fullPath];
        if (!currentPath[verb]) {
            currentPath[verb] = {};
        }
        currentEndpoint = currentPath[verb];
        for (const op of ops) {
            const opTags = getAllTags(program, op);
            if (opTags) {
                const currentTags = currentEndpoint.tags;
                if (currentTags) {
                    // combine tags but eliminate duplicates
                    currentEndpoint.tags = [...new Set([...currentTags, ...opTags])];
                }
                else {
                    currentEndpoint.tags = opTags;
                }
                for (const tag of opTags) {
                    // Add to root tags if not already there
                    tags.add(tag);
                }
            }
        }
        // Set up basic endpoint fields
        currentEndpoint.operationId = shared.operationId;
        for (const op of ops) {
            applyExternalDocs(op, currentEndpoint);
        }
        currentEndpoint.summary = shared.summary;
        currentEndpoint.description = shared.description;
        currentEndpoint.parameters = [];
        currentEndpoint.responses = {};
        const visibility = http.getRequestVisibility(verb);
        emitEndpointParameters(shared.parameters.parameters, visibility);
        if (shared.bodies) {
            if (shared.bodies.length === 1) {
                emitRequestBody(shared.bodies[0], visibility);
            }
            else if (shared.bodies.length > 1) {
                emitMergedRequestBody(shared.bodies, visibility);
            }
        }
        emitSharedResponses(shared.responses);
        for (const op of ops) {
            if (isDeprecated(program, op)) {
                currentEndpoint.deprecated = true;
            }
            attachExtensions(program, op, currentEndpoint);
        }
    }
    function emitOperation(operation) {
        const { path: fullPath, operation: op, verb, parameters } = operation;
        // If path contains a query string, issue msg and don't emit this endpoint
        if (fullPath.indexOf("?") > 0) {
            reportDiagnostic(program, { code: "path-query", target: op });
            return;
        }
        if (!root.paths[fullPath]) {
            root.paths[fullPath] = {};
        }
        currentPath = root.paths[fullPath];
        if (!currentPath[verb]) {
            currentPath[verb] = {};
        }
        currentEndpoint = currentPath[verb];
        const currentTags = getAllTags(program, op);
        if (currentTags) {
            currentEndpoint.tags = currentTags;
            for (const tag of currentTags) {
                // Add to root tags if not already there
                tags.add(tag);
            }
        }
        currentEndpoint.operationId = resolveOperationId(program, operation.operation);
        applyExternalDocs(op, currentEndpoint);
        // Set up basic endpoint fields
        currentEndpoint.summary = getSummary(program, operation.operation);
        currentEndpoint.description = getDoc(program, operation.operation);
        currentEndpoint.parameters = [];
        currentEndpoint.responses = {};
        const visibility = http.getRequestVisibility(verb);
        emitEndpointParameters(parameters.parameters, visibility);
        emitRequestBody(parameters.body, visibility);
        emitResponses(operation.responses);
        if (isDeprecated(program, op)) {
            currentEndpoint.deprecated = true;
        }
        attachExtensions(program, op, currentEndpoint);
    }
    function emitSharedResponses(responses) {
        for (const [_, statusCodeResponses] of responses) {
            if (statusCodeResponses.length === 1) {
                emitResponseObject(statusCodeResponses[0]);
            }
            else {
                emitMergedResponseObject(statusCodeResponses);
            }
        }
    }
    function emitResponses(responses) {
        for (const response of responses) {
            emitResponseObject(response);
        }
    }
    function isBinaryPayload(body, contentType) {
        return (body.kind === "Scalar" &&
            body.name === "bytes" &&
            contentType !== "application/json" &&
            contentType !== "text/plain");
    }
    function getOpenAPIStatuscode(response) {
        switch (response.statusCode) {
            case "*":
                return "default";
            default:
                return response.statusCode;
        }
    }
    function emitMergedResponseObject(responses) {
        var _a, _b;
        const statusCode = getOpenAPIStatuscode(responses[0]);
        const openApiResponse = {
            description: undefined,
            content: {},
            statusCode: statusCode,
        };
        const schemaMap = new Map();
        for (const response of responses) {
            if (response.description && response.description !== openApiResponse.description) {
                openApiResponse.description = openApiResponse.description
                    ? `${openApiResponse.description} ${response.description}`
                    : response.description;
            }
            for (const data of response.responses) {
                if (data.headers && Object.keys(data.headers).length > 0) {
                    (_a = openApiResponse.headers) !== null && _a !== void 0 ? _a : (openApiResponse.headers = {});
                    // OpenAPI can't represent different headers per content type.
                    // So we merge headers here, and report any duplicates.
                    // It may be possible in principle to not error for identically declared
                    // headers.
                    for (const [key, value] of Object.entries(data.headers)) {
                        if (openApiResponse.headers[key]) {
                            reportDiagnostic(program, {
                                code: "duplicate-header",
                                format: { header: key },
                                target: response.type,
                            });
                            continue;
                        }
                        openApiResponse.headers[key] = getResponseHeader(value);
                    }
                }
                if (data.body !== undefined) {
                    (_b = openApiResponse.content) !== null && _b !== void 0 ? _b : (openApiResponse.content = {});
                    for (const contentType of data.body.contentTypes) {
                        const isBinary = isBinaryPayload(data.body.type, contentType);
                        const schema = isBinary
                            ? { type: "string", format: "binary" }
                            : getSchemaOrRef(data.body.type, Visibility.Read);
                        if (schemaMap.has(contentType)) {
                            schemaMap.get(contentType).push(schema);
                        }
                        else {
                            schemaMap.set(contentType, [schema]);
                        }
                    }
                }
                const content = {};
                for (const [contentType, schemaArray] of schemaMap) {
                    if (schemaArray.length === 1) {
                        content[contentType] = { schema: schemaArray[0] };
                    }
                    else {
                        content[contentType] = {
                            schema: { oneOf: schemaArray },
                        };
                    }
                }
                openApiResponse.content = content;
            }
            if (!openApiResponse.description) {
                openApiResponse.description = getResponseDescriptionForStatusCode(statusCode);
            }
            currentEndpoint.responses[statusCode] = openApiResponse;
        }
    }
    function emitResponseObject(response) {
        var _a, _b, _c, _d;
        const statusCode = getOpenAPIStatuscode(response);
        const openapiResponse = (_a = currentEndpoint.responses[statusCode]) !== null && _a !== void 0 ? _a : {
            description: (_b = response.description) !== null && _b !== void 0 ? _b : getResponseDescriptionForStatusCode(statusCode),
        };
        for (const data of response.responses) {
            if (data.headers && Object.keys(data.headers).length > 0) {
                (_c = openapiResponse.headers) !== null && _c !== void 0 ? _c : (openapiResponse.headers = {});
                // OpenAPI can't represent different headers per content type.
                // So we merge headers here, and report any duplicates.
                // It may be possible in principle to not error for identically declared
                // headers.
                for (const [key, value] of Object.entries(data.headers)) {
                    if (openapiResponse.headers[key]) {
                        reportDiagnostic(program, {
                            code: "duplicate-header",
                            format: { header: key },
                            target: response.type,
                        });
                        continue;
                    }
                    openapiResponse.headers[key] = getResponseHeader(value);
                }
            }
            if (data.body !== undefined) {
                (_d = openapiResponse.content) !== null && _d !== void 0 ? _d : (openapiResponse.content = {});
                for (const contentType of data.body.contentTypes) {
                    const isBinary = isBinaryPayload(data.body.type, contentType);
                    const schema = isBinary
                        ? { type: "string", format: "binary" }
                        : getSchemaOrRef(data.body.type, Visibility.Read);
                    openapiResponse.content[contentType] = { schema };
                }
            }
        }
        currentEndpoint.responses[statusCode] = openapiResponse;
    }
    function getResponseDescriptionForStatusCode(statusCode) {
        var _a;
        if (statusCode === "default") {
            return "An unexpected error response.";
        }
        return (_a = getStatusCodeDescription(statusCode)) !== null && _a !== void 0 ? _a : "unknown";
    }
    function getResponseHeader(prop) {
        return getOpenAPIParameterBase(prop, Visibility.Read);
    }
    function getSchemaOrRef(type, visibility) {
        var _a;
        const refUrl = getRef(program, type);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (type.kind === "Scalar" && program.checker.isStdType(type)) {
            return getSchemaForScalar(type);
        }
        if (type.kind === "String" || type.kind === "Number" || type.kind === "Boolean") {
            // For literal types, we just want to emit them directly as well.
            return mapTypeSpecTypeToOpenAPI(type, visibility);
        }
        if (type.kind === "Intrinsic" && type.name === "unknown") {
            return getSchemaForIntrinsicType(type);
        }
        if (type.kind === "EnumMember") {
            // Enum members are just the OA representation of their values.
            if (typeof type.value === "number") {
                return { type: "number", enum: [type.value] };
            }
            else {
                return { type: "string", enum: [(_a = type.value) !== null && _a !== void 0 ? _a : type.name] };
            }
        }
        if (type.kind === "ModelProperty") {
            return resolveProperty(type, visibility);
        }
        type = metadataInfo.getEffectivePayloadType(type, visibility);
        const name = getOpenAPITypeName(program, type, typeNameOptions);
        if (shouldInline(program, type)) {
            const schema = getSchemaForInlineType(type, visibility, name);
            if (schema === undefined && isErrorType(type)) {
                // Exit early so that syntax errors are exposed.  This error will
                // be caught and handled in emitOpenAPI.
                throw new ErrorTypeFoundError();
            }
            // helps to read output and correlate to TypeSpec
            if (schema) {
                schema["x-typespec-name"] = name;
            }
            return schema;
        }
        else {
            // Use shared schema when type is not transformed by visibility from the canonical read visibility.
            if (!metadataInfo.isTransformed(type, visibility)) {
                visibility = Visibility.Read;
            }
            const pending = pendingSchemas.getOrAdd(type, visibility, () => ({
                type,
                visibility,
                ref: refs.getOrAdd(type, visibility, () => new Ref()),
            }));
            return {
                $ref: pending.ref,
            };
        }
    }
    function getSchemaForInlineType(type, visibility, name) {
        if (inProgressInlineTypes.has(type)) {
            reportDiagnostic(program, {
                code: "inline-cycle",
                format: { type: name },
                target: type,
            });
            return {};
        }
        inProgressInlineTypes.add(type);
        const schema = getSchemaForType(type, visibility);
        inProgressInlineTypes.delete(type);
        return schema;
    }
    function getParamPlaceholder(property) {
        let spreadParam = false;
        if (property.sourceProperty) {
            // chase our sources all the way back to the first place this property
            // was defined.
            spreadParam = true;
            property = property.sourceProperty;
            while (property.sourceProperty) {
                property = property.sourceProperty;
            }
        }
        const refUrl = getRef(program, property);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (params.has(property)) {
            return params.get(property);
        }
        const placeholder = {};
        // only parameters inherited by spreading from non-inlined type are shared in #/components/parameters
        if (spreadParam && property.model && !shouldInline(program, property.model)) {
            params.set(property, placeholder);
            paramModels.add(property.model);
        }
        return placeholder;
    }
    function emitEndpointParameters(parameters, visibility) {
        for (const httpOpParam of parameters) {
            if (params.has(httpOpParam.param)) {
                currentEndpoint.parameters.push(params.get(httpOpParam.param));
                continue;
            }
            if (httpOpParam.type === "header" && isContentTypeHeader(program, httpOpParam.param)) {
                continue;
            }
            emitParameter(httpOpParam, visibility);
        }
    }
    function emitMergedRequestBody(bodies, visibility) {
        if (bodies === undefined) {
            return;
        }
        const requestBody = {
            description: undefined,
            content: {},
        };
        const schemaMap = new Map();
        for (const body of bodies) {
            const desc = body.parameter ? getDoc(program, body.parameter) : undefined;
            if (desc) {
                requestBody.description = requestBody.description
                    ? `${requestBody.description} ${desc}`
                    : desc;
            }
            const contentTypes = body.contentTypes.length > 0 ? body.contentTypes : ["application/json"];
            for (const contentType of contentTypes) {
                const isBinary = isBinaryPayload(body.type, contentType);
                const bodySchema = isBinary
                    ? { type: "string", format: "binary" }
                    : getSchemaOrRef(body.type, visibility);
                if (schemaMap.has(contentType)) {
                    schemaMap.get(contentType).push(bodySchema);
                }
                else {
                    schemaMap.set(contentType, [bodySchema]);
                }
            }
        }
        const content = {};
        for (const [contentType, schemaArray] of schemaMap) {
            if (schemaArray.length === 1) {
                content[contentType] = { schema: schemaArray[0] };
            }
            else {
                content[contentType] = {
                    schema: { oneOf: schemaArray },
                };
            }
        }
        requestBody.content = content;
        currentEndpoint.requestBody = requestBody;
    }
    function emitRequestBody(body, visibility) {
        if (body === undefined) {
            return;
        }
        const requestBody = {
            description: body.parameter ? getDoc(program, body.parameter) : undefined,
            content: {},
        };
        const contentTypes = body.contentTypes.length > 0 ? body.contentTypes : ["application/json"];
        for (const contentType of contentTypes) {
            const isBinary = isBinaryPayload(body.type, contentType);
            const bodySchema = isBinary
                ? { type: "string", format: "binary" }
                : getSchemaOrRef(body.type, visibility);
            const contentEntry = {
                schema: bodySchema,
            };
            requestBody.content[contentType] = contentEntry;
        }
        currentEndpoint.requestBody = requestBody;
    }
    function emitParameter(parameter, visibility) {
        if (isNeverType(parameter.param.type)) {
            return;
        }
        const existing = currentEndpoint.parameters.find((p) => p.name === parameter.name && p.in === parameter.type);
        if (existing) {
            populateParameter(existing, parameter, visibility);
        }
        else {
            const ph = getParamPlaceholder(parameter.param);
            currentEndpoint.parameters.push(ph);
            // If the parameter already has a $ref, don't bother populating it
            if (!("$ref" in ph)) {
                populateParameter(ph, parameter, visibility);
            }
        }
    }
    function getOpenAPIParameterBase(param, visibility) {
        const typeSchema = getSchemaForType(param.type, visibility);
        if (!typeSchema) {
            return undefined;
        }
        const schema = applyIntrinsicDecorators(param, typeSchema);
        if (param.default) {
            schema.default = getDefaultValue(param.default);
        }
        // Description is already provided in the parameter itself.
        delete schema.description;
        const oaiParam = {
            required: !param.optional,
            description: getDoc(program, param),
            schema,
        };
        attachExtensions(program, param, oaiParam);
        return oaiParam;
    }
    function mergeOpenApiParameters(param, base) {
        if (param.schema) {
            const schema = param.schema;
            if (schema.enum && base.schema.enum) {
                schema.enum = [...new Set([...schema.enum, ...base.schema.enum])];
            }
            param.schema = schema;
        }
        else {
            Object.assign(param, base);
        }
        return param;
    }
    function populateParameter(ph, parameter, visibility) {
        ph.name = parameter.name;
        ph.in = parameter.type;
        if (parameter.type === "query") {
            if (parameter.format === "csv") {
                ph.style = "simple";
            }
            else if (parameter.format === "multi") {
                ph.style = "form";
                ph.explode = true;
            }
        }
        else if (parameter.type === "header") {
            if (parameter.format === "csv") {
                ph.style = "simple";
            }
        }
        const paramBase = getOpenAPIParameterBase(parameter.param, visibility);
        if (paramBase) {
            ph = mergeOpenApiParameters(ph, paramBase);
        }
    }
    function emitParameters() {
        for (const [property, param] of params) {
            const key = getParameterKey(program, property, param, root.components.parameters, typeNameOptions);
            root.components.parameters[key] = { ...param };
            for (const key of Object.keys(param)) {
                delete param[key];
            }
            param.$ref = "#/components/parameters/" + encodeURIComponent(key);
        }
    }
    function emitSchemas(serviceNamespace) {
        const processedSchemas = new TwoLevelMap();
        processSchemas();
        if (!options.omitUnreachableTypes) {
            processUnreferencedSchemas();
        }
        // Emit the processed schemas. Only now can we compute the names as it
        // depends on whether we have produced multiple schemas for a single
        // TYPESPEC type.
        for (const group of processedSchemas.values()) {
            for (const [visibility, processed] of group) {
                let name = getOpenAPITypeName(program, processed.type, typeNameOptions);
                if (group.size > 1) {
                    name += getVisibilitySuffix(visibility, Visibility.Read);
                }
                checkDuplicateTypeName(program, processed.type, name, root.components.schemas);
                processed.ref.value = "#/components/schemas/" + encodeURIComponent(name);
                if (processed.schema) {
                    root.components.schemas[name] = processed.schema;
                }
            }
        }
        function processSchemas() {
            // Process pending schemas. Note that getSchemaForType may pull in new
            // pending schemas so we iterate until there are no pending schemas
            // remaining.
            while (pendingSchemas.size > 0) {
                for (const [type, group] of pendingSchemas) {
                    for (const [visibility, pending] of group) {
                        processedSchemas.getOrAdd(type, visibility, () => ({
                            ...pending,
                            schema: getSchemaForType(type, visibility),
                        }));
                    }
                    pendingSchemas.delete(type);
                }
            }
        }
        function processUnreferencedSchemas() {
            const addSchema = (type) => {
                if (!processedSchemas.has(type) && !paramModels.has(type) && !shouldInline(program, type)) {
                    getSchemaOrRef(type, Visibility.Read);
                }
            };
            const skipSubNamespaces = isGlobalNamespace(program, serviceNamespace);
            navigateTypesInNamespace(serviceNamespace, {
                model: addSchema,
                scalar: addSchema,
                enum: addSchema,
                union: addSchema,
            }, { skipSubNamespaces });
            processSchemas();
        }
    }
    function emitTags() {
        for (const tag of tags) {
            root.tags.push({ name: tag });
        }
    }
    function getSchemaForType(type, visibility) {
        const builtinType = mapTypeSpecTypeToOpenAPI(type, visibility);
        if (builtinType !== undefined)
            return builtinType;
        switch (type.kind) {
            case "Intrinsic":
                return getSchemaForIntrinsicType(type);
            case "Model":
                return getSchemaForModel(type, visibility);
            case "ModelProperty":
                return getSchemaForType(type.type, visibility);
            case "Scalar":
                return getSchemaForScalar(type);
            case "Union":
                return getSchemaForUnion(type, visibility);
            case "UnionVariant":
                return getSchemaForUnionVariant(type, visibility);
            case "Enum":
                return getSchemaForEnum(type);
            case "Tuple":
                return { type: "array", items: {} };
            case "TemplateParameter":
                // Note: This should never happen if it does there is a bug in the compiler.
                reportDiagnostic(program, {
                    code: "invalid-schema",
                    format: { type: `${type.node.id.sv} (template parameter)` },
                    target: type,
                });
                return undefined;
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.kind },
            target: type,
        });
        return undefined;
    }
    function getSchemaForIntrinsicType(type) {
        switch (type.name) {
            case "unknown":
                return {};
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.name },
            target: type,
        });
        return {};
    }
    function getSchemaForEnum(e) {
        var _a;
        const values = [];
        if (e.members.size === 0) {
            reportUnsupportedUnion("empty");
            return undefined;
        }
        const type = enumMemberType(e.members.values().next().value);
        for (const option of e.members.values()) {
            if (type !== enumMemberType(option)) {
                reportUnsupportedUnion();
                continue;
            }
            values.push((_a = option.value) !== null && _a !== void 0 ? _a : option.name);
        }
        const schema = { type, description: getDoc(program, e) };
        if (values.length > 0) {
            schema.enum = values;
        }
        return schema;
        function enumMemberType(member) {
            if (typeof member.value === "number") {
                return "number";
            }
            return "string";
        }
        function reportUnsupportedUnion(messageId = "default") {
            reportDiagnostic(program, { code: "union-unsupported", messageId, target: e });
        }
    }
    /**
     * A TypeSpec union maps to a variety of OA3 structures according to the following rules:
     *
     * * A union containing `null` makes a `nullable` schema comprised of the remaining
     *   union variants.
     * * A union containing literal types are converted to OA3 enums. All literals of the
     *   same type are combined into single enums.
     * * A union that contains multiple items (after removing null and combining like-typed
     *   literals into enums) is an `anyOf` union unless `oneOf` is applied to the union
     *   declaration.
     */
    function getSchemaForUnion(union, visibility) {
        const variants = Array.from(union.variants.values());
        const literalVariantEnumByType = {};
        const ofType = getOneOf(program, union) ? "oneOf" : "anyOf";
        const schemaMembers = [];
        let nullable = false;
        const discriminator = getDiscriminator(program, union);
        for (const variant of variants) {
            if (isNullType(variant.type)) {
                nullable = true;
                continue;
            }
            if (isLiteralType(variant.type)) {
                if (!literalVariantEnumByType[variant.type.kind]) {
                    const enumSchema = mapTypeSpecTypeToOpenAPI(variant.type, visibility);
                    literalVariantEnumByType[variant.type.kind] = enumSchema;
                    schemaMembers.push({ schema: enumSchema, type: null });
                }
                else {
                    literalVariantEnumByType[variant.type.kind].enum.push(variant.type.value);
                }
                continue;
            }
            schemaMembers.push({ schema: getSchemaOrRef(variant.type, visibility), type: variant.type });
        }
        if (schemaMembers.length === 0) {
            if (nullable) {
                // This union is equivalent to just `null` but OA3 has no way to specify
                // null as a value, so we throw an error.
                reportDiagnostic(program, { code: "union-null", target: union });
                return {};
            }
            else {
                // completely empty union can maybe only happen with bugs?
                compilerAssert(false, "Attempting to emit an empty union");
            }
        }
        if (schemaMembers.length === 1) {
            // we can just return the single schema member after applying nullable
            const schema = schemaMembers[0].schema;
            const type = schemaMembers[0].type;
            if (nullable) {
                if (schema.$ref) {
                    // but we can't make a ref "nullable", so wrap in an allOf (for models)
                    // or oneOf (for all other types)
                    if (type && type.kind === "Model") {
                        return { type: "object", allOf: [schema], nullable: true };
                    }
                    else {
                        return { oneOf: [schema], nullable: true };
                    }
                }
                else {
                    schema.nullable = true;
                }
            }
            return schema;
        }
        const schema = {
            [ofType]: schemaMembers.map((m) => m.schema),
        };
        if (nullable) {
            schema.nullable = true;
        }
        if (discriminator) {
            // the decorator validates that all the variants will be a model type
            // with the discriminator field present.
            schema.discriminator = discriminator;
            // Diagnostic already reported in compiler for unions
            const discriminatedUnion = ignoreDiagnostics(getDiscriminatedUnion(union, discriminator));
            if (discriminatedUnion.variants.size > 0) {
                schema.discriminator.mapping = getDiscriminatorMapping(discriminatedUnion, visibility);
            }
        }
        return schema;
    }
    function getSchemaForUnionVariant(variant, visibility) {
        const schema = getSchemaForType(variant.type, visibility);
        return schema;
    }
    function isLiteralType(type) {
        return type.kind === "Boolean" || type.kind === "String" || type.kind === "Number";
    }
    function getDefaultValue(type) {
        var _a;
        switch (type.kind) {
            case "String":
                return type.value;
            case "Number":
                return type.value;
            case "Boolean":
                return type.value;
            case "Tuple":
                return type.values.map(getDefaultValue);
            case "EnumMember":
                return (_a = type.value) !== null && _a !== void 0 ? _a : type.name;
            default:
                reportDiagnostic(program, {
                    code: "invalid-default",
                    format: { type: type.kind },
                    target: type,
                });
        }
    }
    function includeDerivedModel(model) {
        var _a, _b;
        return (!isTemplateDeclaration(model) &&
            (((_a = model.templateMapper) === null || _a === void 0 ? void 0 : _a.args) === undefined ||
                ((_b = model.templateMapper.args) === null || _b === void 0 ? void 0 : _b.length) === 0 ||
                model.derivedModels.length > 0));
    }
    function getSchemaForModel(model, visibility) {
        let modelSchema = {
            type: "object",
            properties: {},
            description: getDoc(program, model),
        };
        const derivedModels = model.derivedModels.filter(includeDerivedModel);
        // getSchemaOrRef on all children to push them into components.schemas
        for (const child of derivedModels) {
            getSchemaOrRef(child, visibility);
        }
        const discriminator = getDiscriminator(program, model);
        if (discriminator) {
            const [union] = getDiscriminatedUnion(model, discriminator);
            const openApiDiscriminator = { ...discriminator };
            if (union.variants.size > 0) {
                openApiDiscriminator.mapping = getDiscriminatorMapping(union, visibility);
            }
            modelSchema.discriminator = openApiDiscriminator;
            modelSchema.properties[discriminator.propertyName] = {
                type: "string",
                description: `Discriminator property for ${model.name}.`,
            };
        }
        applyExternalDocs(model, modelSchema);
        for (const [name, prop] of model.properties) {
            if (!metadataInfo.isPayloadProperty(prop, visibility)) {
                continue;
            }
            if (isNeverType(prop.type)) {
                // If the property has a type of 'never', don't include it in the schema
                continue;
            }
            if (!metadataInfo.isOptional(prop, visibility)) {
                if (!modelSchema.required) {
                    modelSchema.required = [];
                }
                modelSchema.required.push(name);
            }
            modelSchema.properties[name] = resolveProperty(prop, visibility);
        }
        // Special case: if a model type extends a single *templated* base type and
        // has no properties of its own, absorb the definition of the base model
        // into this schema definition.  The assumption here is that any model type
        // defined like this is just meant to rename the underlying instance of a
        // templated type.
        if (model.baseModel &&
            isTemplateDeclarationOrInstance(model.baseModel) &&
            Object.keys(modelSchema.properties).length === 0) {
            // Take the base model schema but carry across the documentation property
            // that we set before
            const baseSchema = getSchemaForType(model.baseModel, visibility);
            modelSchema = {
                ...baseSchema,
                description: modelSchema.description,
            };
        }
        else if (model.baseModel) {
            const baseSchema = getSchemaOrRef(model.baseModel, visibility);
            modelSchema.allOf = [baseSchema];
            modelSchema.additionalProperties = baseSchema.additionalProperties;
            if (modelSchema.additionalProperties) {
                validateAdditionalProperties(model);
            }
        }
        // Attach any OpenAPI extensions
        attachExtensions(program, model, modelSchema);
        return modelSchema;
    }
    function resolveProperty(prop, visibility) {
        const description = getDoc(program, prop);
        const schema = getSchemaOrRef(prop.type, visibility);
        // Apply decorators on the property to the type's schema
        const additionalProps = applyIntrinsicDecorators(prop, {});
        if (description) {
            additionalProps.description = description;
        }
        if (prop.default) {
            additionalProps.default = getDefaultValue(prop.default);
        }
        if (isReadonlyProperty(program, prop)) {
            additionalProps.readOnly = true;
        }
        // Attach any additional OpenAPI extensions
        attachExtensions(program, prop, additionalProps);
        if (schema && "$ref" in schema) {
            if (Object.keys(additionalProps).length === 0) {
                return schema;
            }
            else {
                return {
                    allOf: [schema],
                    ...additionalProps,
                };
            }
        }
        else {
            return { ...schema, ...additionalProps };
        }
    }
    function attachExtensions(program, type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(program, type);
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    function getDiscriminatorMapping(union, visibility) {
        const mapping = {};
        for (const [key, model] of union.variants.entries()) {
            mapping[key] = getSchemaOrRef(model, visibility).$ref;
        }
        return mapping;
    }
    function applyIntrinsicDecorators(typespecType, target) {
        const newTarget = { ...target };
        const docStr = getDoc(program, typespecType);
        const isString = isStringType(program, getPropertyType(typespecType));
        const isNumeric = isNumericType(program, getPropertyType(typespecType));
        if (!target.description && docStr) {
            newTarget.description = docStr;
        }
        const formatStr = getFormat(program, typespecType);
        if (isString && !target.format && formatStr) {
            newTarget.format = formatStr;
        }
        const pattern = getPattern(program, typespecType);
        if (isString && !target.pattern && pattern) {
            newTarget.pattern = pattern;
        }
        const minLength = getMinLength(program, typespecType);
        if (isString && !target.minLength && minLength !== undefined) {
            newTarget.minLength = minLength;
        }
        const maxLength = getMaxLength(program, typespecType);
        if (isString && !target.maxLength && maxLength !== undefined) {
            newTarget.maxLength = maxLength;
        }
        const minValue = getMinValue(program, typespecType);
        if (isNumeric && !target.minimum && minValue !== undefined) {
            newTarget.minimum = minValue;
        }
        const minValueExclusive = getMinValueExclusive(program, typespecType);
        if (isNumeric && !target.exclusiveMinimum && minValueExclusive !== undefined) {
            newTarget.exclusiveMinimum = minValueExclusive;
        }
        const maxValue = getMaxValue(program, typespecType);
        if (isNumeric && !target.maximum && maxValue !== undefined) {
            newTarget.maximum = maxValue;
        }
        const maxValueExclusive = getMaxValueExclusive(program, typespecType);
        if (isNumeric && !target.exclusiveMaximum && maxValueExclusive !== undefined) {
            newTarget.exclusiveMaximum = maxValueExclusive;
        }
        const minItems = getMinItems(program, typespecType);
        if (!target.minItems && minItems !== undefined) {
            newTarget.minItems = minItems;
        }
        const maxItems = getMaxItems(program, typespecType);
        if (!target.maxItems && maxItems !== undefined) {
            newTarget.maxItems = maxItems;
        }
        if (isSecret(program, typespecType)) {
            newTarget.format = "password";
        }
        if (isString) {
            const values = getKnownValues(program, typespecType);
            if (values) {
                return {
                    oneOf: [newTarget, getSchemaForEnum(values)],
                };
            }
        }
        attachExtensions(program, typespecType, newTarget);
        return newTarget;
    }
    function applyExternalDocs(typespecType, target) {
        const externalDocs = getExternalDocs(program, typespecType);
        if (externalDocs) {
            target.externalDocs = externalDocs;
        }
    }
    // Map an TypeSpec type to an OA schema. Returns undefined when the resulting
    // OA schema is just a regular object schema.
    function mapTypeSpecTypeToOpenAPI(typespecType, visibility) {
        switch (typespecType.kind) {
            case "Number":
                return { type: "number", enum: [typespecType.value] };
            case "String":
                return { type: "string", enum: [typespecType.value] };
            case "Boolean":
                return { type: "boolean", enum: [typespecType.value] };
            case "Model":
                return mapTypeSpecIntrinsicModelToOpenAPI(typespecType, visibility);
        }
    }
    function getIndexer(model) {
        const indexer = model.indexer;
        if (indexer) {
            return indexer;
        }
        else if (model.baseModel) {
            return getIndexer(model.baseModel);
        }
        return undefined;
    }
    function validateAdditionalProperties(model) {
        var _a;
        const propType = (_a = getIndexer(model)) === null || _a === void 0 ? void 0 : _a.value;
        if (!propType) {
            return;
        }
        for (const [_, prop] of model.properties) {
            // ensure that the record type is compatible with any listed properties
            const [_, diagnostics] = program.checker.isTypeAssignableTo(prop.type, propType, prop);
            for (const diag of diagnostics) {
                program.reportDiagnostic(diag);
            }
        }
    }
    /**
     * Returns appropriate additional properties for Record types.
     */
    function processAdditionalProperties(model, visibility) {
        var _a;
        const propType = (_a = getIndexer(model)) === null || _a === void 0 ? void 0 : _a.value;
        if (!propType) {
            return undefined;
        }
        switch (propType.kind) {
            case "Intrinsic":
                if (propType.name === "unknown") {
                    return {};
                }
                break;
            case "Scalar":
            case "Model":
                return getSchemaOrRef(propType, visibility);
        }
        return undefined;
    }
    /**
     * Map TypeSpec intrinsic models to open api definitions
     */
    function mapTypeSpecIntrinsicModelToOpenAPI(typespecType, visibility) {
        if (typespecType.indexer) {
            if (isNeverType(typespecType.indexer.key)) {
            }
            else {
                const name = typespecType.indexer.key.name;
                if (name === "string") {
                    return {
                        type: "object",
                        additionalProperties: processAdditionalProperties(typespecType, visibility),
                    };
                }
                else if (name === "integer") {
                    return {
                        type: "array",
                        items: getSchemaOrRef(typespecType.indexer.value, visibility | Visibility.Item),
                    };
                }
            }
        }
    }
    function getSchemaForScalar(scalar) {
        let result = {};
        if (program.checker.isStdType(scalar)) {
            result = getSchemaForStdScalars(scalar);
        }
        else if (scalar.baseScalar) {
            result = getSchemaForScalar(scalar.baseScalar);
        }
        return applyIntrinsicDecorators(scalar, result);
    }
    function getSchemaForStdScalars(scalar) {
        switch (scalar.name) {
            case "bytes":
                return { type: "string", format: "byte" };
            case "int8":
                return { type: "integer", format: "int8" };
            case "int16":
                return { type: "integer", format: "int16" };
            case "int32":
                return { type: "integer", format: "int32" };
            case "int64":
                return { type: "integer", format: "int64" };
            case "safeint":
                return { type: "integer", format: "int64" };
            case "uint8":
                return { type: "integer", format: "uint8" };
            case "uint16":
                return { type: "integer", format: "uint16" };
            case "uint32":
                return { type: "integer", format: "uint32" };
            case "uint64":
                return { type: "integer", format: "uint64" };
            case "float64":
                return { type: "number", format: "double" };
            case "float32":
                return { type: "number", format: "float" };
            case "string":
                return { type: "string" };
            case "boolean":
                return { type: "boolean" };
            case "plainDate":
                return { type: "string", format: "date" };
            case "utcDateTime":
            case "offsetDateTime":
                return { type: "string", format: "date-time" };
            case "plainTime":
                return { type: "string", format: "time" };
            case "duration":
                return { type: "string", format: "duration" };
            case "url":
                return { type: "string", format: "uri" };
            case "integer":
            case "numeric":
            case "float":
                return {}; // Waiting on design for more precise type https://github.com/microsoft/typespec/issues/1260
            default:
                const _assertNever = scalar.name;
                return {};
        }
    }
    function processAuth(serviceNamespace) {
        const authentication = getAuthentication(program, serviceNamespace);
        if (authentication) {
            return processServiceAuthentication(authentication);
        }
        return undefined;
    }
    function processServiceAuthentication(authentication) {
        const oaiSchemes = {};
        const security = [];
        for (const option of authentication.options) {
            const oai3SecurityOption = {};
            for (const scheme of option.schemes) {
                const [oaiScheme, scopes] = getOpenAPI3Scheme(scheme);
                oaiSchemes[scheme.id] = oaiScheme;
                oai3SecurityOption[scheme.id] = scopes;
            }
            security.push(oai3SecurityOption);
        }
        return { securitySchemes: oaiSchemes, security };
    }
    function getOpenAPI3Scheme(auth) {
        switch (auth.type) {
            case "http":
                return [{ type: "http", scheme: auth.scheme, description: auth.description }, []];
            case "apiKey":
                return [
                    { type: "apiKey", in: auth.in, name: auth.name, description: auth.description },
                    [],
                ];
            case "oauth2":
                const flows = {};
                const scopes = [];
                for (const flow of auth.flows) {
                    scopes.push(...flow.scopes.map((x) => x.value));
                    flows[flow.type] = {
                        authorizationUrl: flow.authorizationUrl,
                        tokenUrl: flow.tokenUrl,
                        refreshUrl: flow.refreshUrl,
                        scopes: Object.fromEntries(flow.scopes.map((x) => { var _a; return [x.value, (_a = x.description) !== null && _a !== void 0 ? _a : ""]; })),
                    };
                }
                return [{ type: "oauth2", flows, description: auth.description }, scopes];
            default:
                const _assertNever = auth;
                compilerAssert(false, "Unreachable");
        }
    }
}
function serializeDocument(root, fileType) {
    sortOpenAPIDocument(root);
    switch (fileType) {
        case "json":
            return prettierOutput(JSON.stringify(root, null, 2));
        case "yaml":
            return yaml.dump(root, {
                noRefs: true,
                replacer: function (key, value) {
                    return value instanceof Ref ? value.toJSON() : value;
                },
            });
    }
}
function prettierOutput(output) {
    return output + "\n";
}
class ErrorTypeFoundError extends Error {
    constructor() {
        super("Error type found in evaluated TypeSpec output");
    }
}
function sortObjectByKeys(obj) {
    return Object.keys(obj)
        .sort()
        .reduce((sortedObj, key) => {
        sortedObj[key] = obj[key];
        return sortedObj;
    }, {});
}
function sortOpenAPIDocument(doc) {
    var _a, _b;
    doc.paths = sortObjectByKeys(doc.paths);
    if ((_a = doc.components) === null || _a === void 0 ? void 0 : _a.schemas) {
        doc.components.schemas = sortObjectByKeys(doc.components.schemas);
    }
    if ((_b = doc.components) === null || _b === void 0 ? void 0 : _b.parameters) {
        doc.components.parameters = sortObjectByKeys(doc.components.parameters);
    }
}
//# sourceMappingURL=openapi.js.map