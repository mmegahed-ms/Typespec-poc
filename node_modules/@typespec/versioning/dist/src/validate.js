import { getNamespaceFullName, getTypeName, isTemplateInstance, navigateProgram, NoTarget, } from "@typespec/compiler";
import { reportDiagnostic } from "./lib.js";
import { Availability, findVersionedNamespace, getAvailabilityMap, getMadeOptionalOn, getUseDependencies, getVersionDependencies, getVersions, } from "./versioning.js";
export function $onValidate(program) {
    const namespaceDependencies = new Map();
    function addDependency(source, target) {
        var _a;
        if (!target || !("namespace" in target) || !target.namespace) {
            return;
        }
        const set = (_a = namespaceDependencies.get(source)) !== null && _a !== void 0 ? _a : new Set();
        if (target.namespace !== source) {
            set.add(target.namespace);
        }
        namespaceDependencies.set(source, set);
    }
    navigateProgram(program, {
        model: (model) => {
            // If this is an instantiated type we don't want to keep the mapping.
            if (isTemplateInstance(model)) {
                return;
            }
            addDependency(model.namespace, model.baseModel);
            for (const prop of model.properties.values()) {
                addDependency(model.namespace, prop.type);
                // Validate model -> property have correct versioning
                validateTargetVersionCompatible(program, model, prop, { isTargetADependent: true });
                // Validate model property -> type have correct versioning
                validateReference(program, prop, prop.type);
                // Validate model property type is correct when madeOptional
                validateMadeOptional(program, prop);
            }
        },
        union: (union) => {
            // If this is an instantiated type we don't want to keep the mapping.
            if (isTemplateInstance(union)) {
                return;
            }
            if (union.namespace === undefined) {
                return;
            }
            for (const variant of union.variants.values()) {
                addDependency(union.namespace, variant.type);
            }
        },
        operation: (op) => {
            var _a, _b;
            // If this is an instantiated type we don't want to keep the mapping.
            if (isTemplateInstance(op)) {
                return;
            }
            const namespace = (_a = op.namespace) !== null && _a !== void 0 ? _a : (_b = op.interface) === null || _b === void 0 ? void 0 : _b.namespace;
            addDependency(namespace, op.parameters);
            addDependency(namespace, op.returnType);
            if (op.interface) {
                // Validate model -> property have correct versioning
                validateTargetVersionCompatible(program, op.interface, op, { isTargetADependent: true });
            }
            validateReference(program, op, op.returnType);
        },
        interface: (iface) => {
            for (const source of iface.sourceInterfaces) {
                validateReference(program, iface, source);
            }
        },
        namespace: (namespace) => {
            const versionedNamespace = findVersionedNamespace(program, namespace);
            const dependencies = getVersionDependencies(program, namespace);
            if (dependencies === undefined) {
                return;
            }
            for (const [dependencyNs, value] of dependencies.entries()) {
                if (versionedNamespace) {
                    const usingUseDependency = getUseDependencies(program, namespace, false) !== undefined;
                    if (usingUseDependency) {
                        reportDiagnostic(program, {
                            code: "incompatible-versioned-namespace-use-dependency",
                            target: namespace,
                        });
                    }
                    else if (!(value instanceof Map)) {
                        reportDiagnostic(program, {
                            code: "versioned-dependency-record-not-mapping",
                            format: { dependency: getNamespaceFullName(dependencyNs) },
                            target: namespace,
                        });
                    }
                }
                else {
                    if (value instanceof Map) {
                        reportDiagnostic(program, {
                            code: "versioned-dependency-not-picked",
                            format: { dependency: getNamespaceFullName(dependencyNs) },
                            target: namespace,
                        });
                    }
                }
            }
        },
        enum: (en) => {
            // construct the list of tuples in the old format if version
            // information is placed in the Version enum members
            const useDependencies = getUseDependencies(program, en);
            if (!useDependencies) {
                return;
            }
            for (const [depNs, deps] of useDependencies) {
                const set = new Set();
                if (deps instanceof Map) {
                    for (const val of deps.values()) {
                        set.add(val.namespace);
                    }
                }
                else {
                    set.add(deps.namespace);
                }
                namespaceDependencies.set(depNs, set);
            }
        },
    }, { includeTemplateDeclaration: true });
    validateVersionedNamespaceUsage(program, namespaceDependencies);
}
function validateVersionedNamespaceUsage(program, namespaceDependencies) {
    for (const [source, targets] of namespaceDependencies.entries()) {
        const dependencies = source && getVersionDependencies(program, source);
        for (const target of targets) {
            const targetVersionedNamespace = findVersionedNamespace(program, target);
            if (targetVersionedNamespace !== undefined &&
                !(source && (isSubNamespace(target, source) || isSubNamespace(source, target))) &&
                (dependencies === null || dependencies === void 0 ? void 0 : dependencies.get(targetVersionedNamespace)) === undefined) {
                reportDiagnostic(program, {
                    code: "using-versioned-library",
                    format: {
                        sourceNs: source ? getNamespaceFullName(source) : "global",
                        targetNs: getNamespaceFullName(target),
                    },
                    target: source !== null && source !== void 0 ? source : NoTarget,
                });
            }
        }
    }
}
function isSubNamespace(parent, child) {
    let current = child;
    while (current && current.name !== "") {
        if (current === parent) {
            return true;
        }
        current = current.namespace;
    }
    return false;
}
function validateMadeOptional(program, target) {
    if (target.kind === "ModelProperty") {
        const madeOptionalOn = getMadeOptionalOn(program, target);
        if (!madeOptionalOn) {
            return;
        }
        // if the @madeOptional decorator is on a property it MUST be optional
        if (!target.optional) {
            reportDiagnostic(program, {
                code: "made-optional-not-optional",
                format: {
                    name: target.name,
                },
                target: target,
            });
            return;
        }
    }
}
/**
 * Validate the target reference versioning is compatible with the source versioning.
 * This will also validate any template arguments used in the reference.
 * e.g. The target cannot be added after the source was added.
 * @param source Source type referencing the target type.
 * @param target Type being referenced from the source
 */
function validateReference(program, source, target) {
    var _a, _b;
    validateTargetVersionCompatible(program, source, target);
    if ("templateMapper" in target) {
        for (const param of (_b = (_a = target.templateMapper) === null || _a === void 0 ? void 0 : _a.args) !== null && _b !== void 0 ? _b : []) {
            validateTargetVersionCompatible(program, source, param);
        }
    }
    switch (target.kind) {
        case "Union":
            for (const variant of target.variants.values()) {
                validateTargetVersionCompatible(program, source, variant.type);
            }
            break;
        case "Tuple":
            for (const value of target.values) {
                validateTargetVersionCompatible(program, source, value);
            }
            break;
    }
}
function getAvailabilityMapWithParentInfo(program, type) {
    const base = getAvailabilityMap(program, type);
    // get any parent availability information
    let parentMap = undefined;
    switch (type.kind) {
        case "Operation":
            const parentInterface = type.interface;
            if (parentInterface) {
                parentMap = getAvailabilityMap(program, parentInterface);
            }
            break;
        case "ModelProperty":
            const parentModel = type.model;
            if (parentModel) {
                parentMap = getAvailabilityMap(program, parentModel);
            }
            break;
        default:
            break;
    }
    if (!base && !parentMap)
        return undefined;
    else if (!base && parentMap)
        return parentMap;
    else
        return base;
}
/**
 * Validate the target versioning is compatible with the versioning of the source.
 * e.g. The target cannot be added after the source was added.
 * @param source Source type referencing the target type.
 * @param target Type being referenced from the source
 */
function validateTargetVersionCompatible(program, source, target, validateOptions = {}) {
    const sourceAvailability = getAvailabilityMapWithParentInfo(program, source);
    const [sourceNamespace] = getVersions(program, source);
    let targetAvailability = getAvailabilityMapWithParentInfo(program, target);
    const [targetNamespace] = getVersions(program, target);
    if (!targetAvailability || !targetNamespace)
        return;
    if (sourceNamespace !== targetNamespace) {
        const dependencies = getVersionDependencies(program, source.namespace);
        const versionMap = dependencies === null || dependencies === void 0 ? void 0 : dependencies.get(targetNamespace);
        if (versionMap === undefined)
            return;
        targetAvailability = translateAvailability(program, targetAvailability, versionMap, source, target);
        if (!targetAvailability) {
            return;
        }
    }
    if (validateOptions.isTargetADependent) {
        validateAvailabilityForContains(program, sourceAvailability, targetAvailability, source, target);
    }
    else {
        validateAvailabilityForRef(program, sourceAvailability, targetAvailability, source, target);
    }
}
function translateAvailability(program, avail, versionMap, source, target) {
    if (!(versionMap instanceof Map)) {
        const version = versionMap;
        if ([Availability.Removed, Availability.Unavailable].includes(avail.get(version.name))) {
            const addedAfter = findAvailabilityAfterVersion(version.name, Availability.Added, avail);
            const removedBefore = findAvailabilityOnOrBeforeVersion(version.name, Availability.Removed, avail);
            if (addedAfter) {
                reportDiagnostic(program, {
                    code: "incompatible-versioned-reference",
                    messageId: "versionedDependencyAddedAfter",
                    format: {
                        sourceName: getTypeName(source),
                        targetName: getTypeName(target),
                        dependencyVersion: prettyVersion(version),
                        targetAddedOn: addedAfter,
                    },
                    target: source,
                });
            }
            if (removedBefore) {
                reportDiagnostic(program, {
                    code: "incompatible-versioned-reference",
                    messageId: "versionedDependencyRemovedBefore",
                    format: {
                        sourceName: getTypeName(source),
                        targetName: getTypeName(target),
                        dependencyVersion: prettyVersion(version),
                        targetAddedOn: removedBefore,
                    },
                    target: source,
                });
            }
        }
        return undefined;
    }
    else {
        const newAvail = new Map();
        for (const [key, val] of versionMap) {
            const isAvail = avail.get(val.name);
            newAvail.set(key.name, isAvail);
        }
        return newAvail;
    }
}
function findAvailabilityAfterVersion(version, status, avail) {
    let search = false;
    for (const [key, val] of avail) {
        if (version === key) {
            search = true;
            continue;
        }
        if (!search)
            continue;
        if (val === status)
            return key;
    }
    return undefined;
}
function findAvailabilityOnOrBeforeVersion(version, status, avail) {
    let search = false;
    for (const [key, val] of avail) {
        if ([Availability.Added, Availability.Added].includes(val)) {
            search = true;
        }
        if (!search)
            continue;
        if (val === status) {
            return key;
        }
        if (key === version) {
            break;
        }
    }
    return undefined;
}
function validateAvailabilityForRef(program, sourceAvail, targetAvail, source, target) {
    // if source is unversioned and target is versioned
    if (sourceAvail === undefined) {
        if (!isAvailableInAllVersion(targetAvail)) {
            reportDiagnostic(program, {
                code: "incompatible-versioned-reference",
                messageId: "default",
                format: {
                    sourceName: getTypeName(source),
                    targetName: getTypeName(target),
                },
                target: source,
            });
        }
        return;
    }
    const keySet = new Set([...sourceAvail.keys(), ...targetAvail.keys()]);
    for (const key of keySet) {
        const sourceVal = sourceAvail.get(key);
        const targetVal = targetAvail.get(key);
        if ([Availability.Added].includes(sourceVal) &&
            [Availability.Removed, Availability.Unavailable].includes(targetVal)) {
            const targetAddedOn = findAvailabilityAfterVersion(key, Availability.Added, targetAvail);
            reportDiagnostic(program, {
                code: "incompatible-versioned-reference",
                messageId: "addedAfter",
                format: {
                    sourceName: getTypeName(source),
                    targetName: getTypeName(target),
                    sourceAddedOn: key,
                    targetAddedOn: targetAddedOn,
                },
                target: source,
            });
        }
        if ([Availability.Removed].includes(sourceVal) &&
            [Availability.Unavailable].includes(targetVal)) {
            const targetRemovedOn = findAvailabilityOnOrBeforeVersion(key, Availability.Removed, targetAvail);
            reportDiagnostic(program, {
                code: "incompatible-versioned-reference",
                messageId: "removedBefore",
                format: {
                    sourceName: getTypeName(source),
                    targetName: getTypeName(target),
                    sourceRemovedOn: key,
                    targetRemovedOn: targetRemovedOn,
                },
                target: source,
            });
        }
    }
}
function validateAvailabilityForContains(program, sourceAvail, targetAvail, source, target) {
    if (!sourceAvail)
        return;
    const keySet = new Set([...sourceAvail.keys(), ...targetAvail.keys()]);
    for (const key of keySet) {
        const sourceVal = sourceAvail.get(key);
        const targetVal = targetAvail.get(key);
        if ([Availability.Added].includes(targetVal) &&
            [Availability.Removed, Availability.Unavailable].includes(sourceVal)) {
            const sourceAddedOn = findAvailabilityOnOrBeforeVersion(key, Availability.Added, sourceAvail);
            reportDiagnostic(program, {
                code: "incompatible-versioned-reference",
                messageId: "dependentAddedAfter",
                format: {
                    sourceName: getTypeName(source),
                    targetName: getTypeName(target),
                    sourceAddedOn: sourceAddedOn,
                    targetAddedOn: key,
                },
                target: target,
            });
        }
        if ([Availability.Removed].includes(sourceVal) &&
            [Availability.Added, Availability.Available].includes(targetVal)) {
            const targetRemovedOn = findAvailabilityAfterVersion(key, Availability.Removed, targetAvail);
            reportDiagnostic(program, {
                code: "incompatible-versioned-reference",
                messageId: "dependentRemovedBefore",
                format: {
                    sourceName: getTypeName(source),
                    targetName: getTypeName(target),
                    sourceRemovedOn: key,
                    targetRemovedOn: targetRemovedOn,
                },
                target: target,
            });
        }
    }
}
function isAvailableInAllVersion(avail) {
    for (const val of avail.values()) {
        if ([Availability.Removed, Availability.Unavailable].includes(val))
            return false;
    }
    return true;
}
function prettyVersion(version) {
    var _a;
    return (_a = version === null || version === void 0 ? void 0 : version.value) !== null && _a !== void 0 ? _a : "<n/a>";
}
//# sourceMappingURL=validate.js.map