declare const httpLib: import("@typespec/compiler").TypeSpecLibrary<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "http-verb-wrong-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "entityKind"]>;
    };
    "missing-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "optional-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "duplicate-response": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "statusCode"]>;
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "no-routes": {
        readonly default: "Current spec is not exposing any routes. This could be to not having the service namespace marked with @service.";
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-boolean": {
        readonly default: "shared parameter must be a boolean.";
    };
    "shared-inconsistency": {
        readonly default: "All shared routes must agree on the value of the shared parameter.";
    };
    "write-visibility-not-supported": {
        readonly default: "@visibility(\"write\") is not supported. Use @visibility(\"update\"), @visibility(\"create\") or @visibility(\"create\", \"update\") as appropriate.";
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model.";
    };
    "header-format-required": {
        readonly default: "A format must be specified for @header when type is an array. e.g. @header({format: \"csv\"})";
    };
    "query-format-required": {
        readonly default: "A format must be specified for @query when type is an array. e.g. @query({format: \"multi\"})";
    };
}, Record<string, any>>;
declare const reportDiagnostic: <C extends "http-verb-duplicate" | "http-verb-wrong-type" | "missing-path-param" | "optional-path-param" | "missing-server-param" | "duplicate-body" | "duplicate-route-decorator" | "operation-param-duplicate-type" | "duplicate-operation" | "status-code-invalid" | "content-type-string" | "duplicate-response" | "content-type-ignored" | "no-routes" | "invalid-type-for-auth" | "shared-boolean" | "shared-inconsistency" | "write-visibility-not-supported" | "multipart-model" | "header-format-required" | "query-format-required", M extends keyof {
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "http-verb-wrong-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "entityKind"]>;
    };
    "missing-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "optional-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "duplicate-response": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "statusCode"]>;
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "no-routes": {
        readonly default: "Current spec is not exposing any routes. This could be to not having the service namespace marked with @service.";
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-boolean": {
        readonly default: "shared parameter must be a boolean.";
    };
    "shared-inconsistency": {
        readonly default: "All shared routes must agree on the value of the shared parameter.";
    };
    "write-visibility-not-supported": {
        readonly default: "@visibility(\"write\") is not supported. Use @visibility(\"update\"), @visibility(\"create\") or @visibility(\"create\", \"update\") as appropriate.";
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model.";
    };
    "header-format-required": {
        readonly default: "A format must be specified for @header when type is an array. e.g. @header({format: \"csv\"})";
    };
    "query-format-required": {
        readonly default: "A format must be specified for @query when type is an array. e.g. @query({format: \"multi\"})";
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "http-verb-wrong-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "entityKind"]>;
    };
    "missing-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "optional-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "duplicate-response": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "statusCode"]>;
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "no-routes": {
        readonly default: "Current spec is not exposing any routes. This could be to not having the service namespace marked with @service.";
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-boolean": {
        readonly default: "shared parameter must be a boolean.";
    };
    "shared-inconsistency": {
        readonly default: "All shared routes must agree on the value of the shared parameter.";
    };
    "write-visibility-not-supported": {
        readonly default: "@visibility(\"write\") is not supported. Use @visibility(\"update\"), @visibility(\"create\") or @visibility(\"create\", \"update\") as appropriate.";
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model.";
    };
    "header-format-required": {
        readonly default: "A format must be specified for @header when type is an array. e.g. @header({format: \"csv\"})";
    };
    "query-format-required": {
        readonly default: "A format must be specified for @query when type is an array. e.g. @query({format: \"multi\"})";
    };
}, C, M>) => void, createDiagnostic: <C extends "http-verb-duplicate" | "http-verb-wrong-type" | "missing-path-param" | "optional-path-param" | "missing-server-param" | "duplicate-body" | "duplicate-route-decorator" | "operation-param-duplicate-type" | "duplicate-operation" | "status-code-invalid" | "content-type-string" | "duplicate-response" | "content-type-ignored" | "no-routes" | "invalid-type-for-auth" | "shared-boolean" | "shared-inconsistency" | "write-visibility-not-supported" | "multipart-model" | "header-format-required" | "query-format-required", M extends keyof {
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "http-verb-wrong-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "entityKind"]>;
    };
    "missing-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "optional-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "duplicate-response": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "statusCode"]>;
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "no-routes": {
        readonly default: "Current spec is not exposing any routes. This could be to not having the service namespace marked with @service.";
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-boolean": {
        readonly default: "shared parameter must be a boolean.";
    };
    "shared-inconsistency": {
        readonly default: "All shared routes must agree on the value of the shared parameter.";
    };
    "write-visibility-not-supported": {
        readonly default: "@visibility(\"write\") is not supported. Use @visibility(\"update\"), @visibility(\"create\") or @visibility(\"create\", \"update\") as appropriate.";
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model.";
    };
    "header-format-required": {
        readonly default: "A format must be specified for @header when type is an array. e.g. @header({format: \"csv\"})";
    };
    "query-format-required": {
        readonly default: "A format must be specified for @query when type is an array. e.g. @query({format: \"multi\"})";
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "http-verb-duplicate": {
        readonly default: import("@typespec/compiler").CallableMessage<["entityName"]>;
    };
    "http-verb-wrong-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["verb", "entityKind"]>;
    };
    "missing-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "optional-path-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName"]>;
    };
    "missing-server-param": {
        readonly default: import("@typespec/compiler").CallableMessage<["param"]>;
    };
    "duplicate-body": {
        readonly default: "Operation has multiple @body parameters declared";
        readonly duplicateUnannotated: "Operation has multiple unannotated parameters. There can only be one representing the body";
        readonly bodyAndUnannotated: "Operation has a @body and an unannotated parameter. There can only be one representing the body";
    };
    "duplicate-route-decorator": {
        readonly namespace: "@route was defined twice on this namespace and has different values.";
    };
    "operation-param-duplicate-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["paramName", "types"]>;
    };
    "duplicate-operation": {
        readonly default: import("@typespec/compiler").CallableMessage<["operationName", "verb", "path"]>;
    };
    "status-code-invalid": {
        readonly default: "statusCode value must be a numeric or string literal or union of numeric or string literals";
        readonly value: "statusCode value must be a three digit code between 100 and 599";
    };
    "content-type-string": {
        readonly default: "contentType parameter must be a string literal or union of string literals";
    };
    "duplicate-response": {
        readonly default: import("@typespec/compiler").CallableMessage<["contentType", "statusCode"]>;
    };
    "content-type-ignored": {
        readonly default: "`Content-Type` header ignored because there is no body.";
    };
    "no-routes": {
        readonly default: "Current spec is not exposing any routes. This could be to not having the service namespace marked with @service.";
    };
    "invalid-type-for-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["kind"]>;
    };
    "shared-boolean": {
        readonly default: "shared parameter must be a boolean.";
    };
    "shared-inconsistency": {
        readonly default: "All shared routes must agree on the value of the shared parameter.";
    };
    "write-visibility-not-supported": {
        readonly default: "@visibility(\"write\") is not supported. Use @visibility(\"update\"), @visibility(\"create\") or @visibility(\"create\", \"update\") as appropriate.";
    };
    "multipart-model": {
        readonly default: "Multipart request body must be a model.";
    };
    "header-format-required": {
        readonly default: "A format must be specified for @header when type is an array. e.g. @header({format: \"csv\"})";
    };
    "query-format-required": {
        readonly default: "A format must be specified for @query when type is an array. e.g. @query({format: \"multi\"})";
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, createStateSymbol: (name: string) => symbol;
export { httpLib, reportDiagnostic, createDiagnostic, createStateSymbol };
//# sourceMappingURL=lib.d.ts.map