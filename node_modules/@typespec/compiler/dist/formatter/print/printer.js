import prettier from "prettier";
import { isIdentifierContinue, isIdentifierStart, utf16CodeUnits } from "../../core/charcode.js";
import { compilerAssert } from "../../core/diagnostics.js";
import { Keywords } from "../../core/scanner.js";
import { SyntaxKind, } from "../../core/types.js";
import { isArray } from "../../core/util.js";
import { commentHandler } from "./comment-handler.js";
import { needsParens } from "./needs-parens.js";
const { align, breakParent, group, hardline, ifBreak, indent, join, line, softline } = prettier.doc.builders;
const { isNextLineEmpty } = prettier.util;
export const typespecPrinter = {
    print: printTypeSpec,
    canAttachComment: canAttachComment,
    printComment: printComment,
    handleComments: commentHandler,
};
export function printTypeSpec(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    const directives = shouldPrintDirective(node) ? printDirectives(path, options, print) : "";
    const printedNode = printNode(path, options, print);
    const value = needsParens(path, options) ? ["(", printedNode, ")"] : printedNode;
    const parts = [directives, value];
    if (node.kind === SyntaxKind.TypeSpecScript) {
        // For TypeSpecScript(root of typespec document) we had a new line at the end.
        // This must be done here so the hardline entry can be the last item of the doc array returned by the printer
        // so the markdown(and other embedded formatter) can omit that extra line.
        parts.push(hardline);
    }
    return parts;
}
function shouldPrintDirective(node) {
    // Model property handle printing directive itself.
    return node.kind !== SyntaxKind.ModelProperty;
}
export function printNode(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    printDirectives(path, options, print);
    switch (node.kind) {
        // Root
        case SyntaxKind.TypeSpecScript:
            return [
                printStatementSequence(path, options, print, "statements"),
            ];
        // Statements
        case SyntaxKind.ImportStatement:
            return [`import "${node.path.value}";`];
        case SyntaxKind.UsingStatement:
            return [`using `, path.call(print, "name"), `;`];
        case SyntaxKind.OperationStatement:
            return printOperationStatement(path, options, print);
        case SyntaxKind.OperationSignatureDeclaration:
            return printOperationSignatureDeclaration(path, options, print);
        case SyntaxKind.OperationSignatureReference:
            return printOperationSignatureReference(path, options, print);
        case SyntaxKind.NamespaceStatement:
            return printNamespaceStatement(path, options, print);
        case SyntaxKind.ModelStatement:
            return printModelStatement(path, options, print);
        case SyntaxKind.ScalarStatement:
            return printScalarStatement(path, options, print);
        case SyntaxKind.AliasStatement:
            return printAliasStatement(path, options, print);
        case SyntaxKind.EnumStatement:
            return printEnumStatement(path, options, print);
        case SyntaxKind.UnionStatement:
            return printUnionStatement(path, options, print);
        case SyntaxKind.InterfaceStatement:
            return printInterfaceStatement(path, options, print);
        // Others.
        case SyntaxKind.Identifier:
            return printIdentifier(node, options);
        case SyntaxKind.StringLiteral:
            return printStringLiteral(path, options);
        case SyntaxKind.NumericLiteral:
            return printNumberLiteral(path, options);
        case SyntaxKind.BooleanLiteral:
            return printBooleanLiteral(path, options);
        case SyntaxKind.ModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.DecoratorExpression:
            return printDecorator(path, options, print);
        case SyntaxKind.AugmentDecoratorStatement:
            return printAugmentDecorator(path, options, print);
        case SyntaxKind.DirectiveExpression:
            return printDirective(path, options, print);
        case SyntaxKind.UnionExpression:
            return printUnion(path, options, print);
        case SyntaxKind.IntersectionExpression:
            return printIntersection(path, options, print);
        case SyntaxKind.ArrayExpression:
            return printArray(path, options, print);
        case SyntaxKind.TupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.MemberExpression:
            return printMemberExpression(path, options, print);
        case SyntaxKind.EnumMember:
            return printEnumMember(path, options, print);
        case SyntaxKind.EnumSpreadMember:
            return printEnumSpreadMember(path, options, print);
        case SyntaxKind.UnionVariant:
            return printUnionVariant(path, options, print);
        case SyntaxKind.TypeReference:
            return printTypeReference(path, options, print);
        case SyntaxKind.TemplateParameterDeclaration:
            return printTemplateParameterDeclaration(path, options, print);
        case SyntaxKind.ModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.DecoratorDeclarationStatement:
            return printDecoratorDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionDeclarationStatement:
            return printFunctionDeclarationStatement(path, options, print);
        case SyntaxKind.FunctionParameter:
            return printFunctionParameterDeclaration(path, options, print);
        case SyntaxKind.ExternKeyword:
            return "extern";
        case SyntaxKind.VoidKeyword:
            return "void";
        case SyntaxKind.NeverKeyword:
            return "never";
        case SyntaxKind.UnknownKeyword:
            return "unknown";
        case SyntaxKind.ProjectionStatement:
            return printProjectionStatement(path, options, print);
        case SyntaxKind.ProjectionModelSelector:
            return "model";
        case SyntaxKind.ProjectionModelPropertySelector:
            return "modelproperty";
        case SyntaxKind.ProjectionOperationSelector:
            return "op";
        case SyntaxKind.ProjectionUnionSelector:
            return "union";
        case SyntaxKind.ProjectionUnionVariantSelector:
            return "unionvariant";
        case SyntaxKind.ProjectionInterfaceSelector:
            return "interface";
        case SyntaxKind.ProjectionEnumSelector:
            return "enum";
        case SyntaxKind.ProjectionEnumMemberSelector:
            return "enummember";
        case SyntaxKind.Projection:
            return printProjection(path, options, print);
        case SyntaxKind.ProjectionParameterDeclaration:
            return printProjectionParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionExpressionStatement:
            return printProjectionExpressionStatement(path, options, print);
        case SyntaxKind.ProjectionIfExpression:
            return printProjectionIfExpressionNode(path, options, print);
        case SyntaxKind.ProjectionBlockExpression:
            return printProjectionBlockExpressionNode(path, options, print);
        case SyntaxKind.ProjectionMemberExpression:
            return printProjectionMemberExpression(path, options, print);
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionEqualityExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
            return printProjectionLeftRightExpression(path, options, print);
        case SyntaxKind.ProjectionUnaryExpression:
            return printProjectionUnaryExpression(path, options, print);
        case SyntaxKind.ProjectionCallExpression:
            return printProjectionCallExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaExpression:
            return printProjectionLambdaExpression(path, options, print);
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
            return printProjectionLambdaParameterDeclaration(path, options, print);
        case SyntaxKind.ProjectionModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ProjectionModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.ProjectionModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.ProjectionTupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
            return path.call(print, "target");
        case SyntaxKind.Return:
            return printReturnExpression(path, options, print);
        case SyntaxKind.Doc:
        case SyntaxKind.DocText:
        case SyntaxKind.DocParamTag:
        case SyntaxKind.DocTemplateTag:
        case SyntaxKind.DocReturnsTag:
        case SyntaxKind.DocUnknownTag:
            // https://github.com/microsoft/typespec/issues/1319 Tracks pretty-printing doc comments.
            compilerAssert(false, "Currently, doc comments are only handled as regular comments and we do not opt in to parsing them so we shouldn't reach here.");
            return "";
        case SyntaxKind.JsSourceFile:
        case SyntaxKind.EmptyStatement:
        case SyntaxKind.InvalidStatement:
            return getRawText(node, options);
        default:
            // Dummy const to ensure we handle all node types.
            // If you get an error here, add a case for the new node type
            // you added..
            const _assertNever = node;
            return getRawText(node, options);
    }
}
export function printAliasStatement(path, options, print) {
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    return ["alias ", id, template, " = ", path.call(print, "value"), ";"];
}
function printTemplateParameters(path, options, print, propertyName) {
    const node = path.getValue();
    const args = node[propertyName];
    if (args.length === 0) {
        return "";
    }
    const shouldHug = args.length === 1;
    if (shouldHug) {
        return ["<", join(", ", path.map(print, propertyName)), ">"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, propertyName))]);
        return group(["<", body, softline, ">"]);
    }
}
export function canAttachComment(node) {
    const kind = node.kind;
    return Boolean(kind &&
        kind !== SyntaxKind.LineComment &&
        kind !== SyntaxKind.BlockComment &&
        !(node.flags & 8 /* NodeFlags.Synthetic */));
}
export function printComment(commentPath, options) {
    const comment = commentPath.getValue();
    comment.printed = true;
    switch (comment.kind) {
        case SyntaxKind.BlockComment:
            return printBlockComment(commentPath, options);
        case SyntaxKind.LineComment:
            return `${options.originalText.slice(comment.pos, comment.end).trimRight()}`;
        default:
            throw new Error(`Not a comment: ${JSON.stringify(comment)}`);
    }
}
function printBlockComment(commentPath, options) {
    const comment = commentPath.getValue();
    const rawComment = options.originalText.slice(comment.pos + 2, comment.end - 2);
    if (isIndentableBlockComment(rawComment)) {
        const printed = printIndentableBlockComment(rawComment);
        return printed;
    }
    return ["/*", rawComment, "*/"];
}
function isIndentableBlockComment(rawComment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${rawComment}*`.split("\n");
    return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
}
function printIndentableBlockComment(rawComment) {
    const lines = rawComment.split("\n");
    return [
        "/*",
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimEnd()
            : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))),
        "*/",
    ];
}
export function printDecorators(path, options, print, { tryInline }) {
    const node = path.getValue();
    if (node.decorators.length === 0) {
        return { decorators: "", multiline: false };
    }
    const shouldBreak = !tryInline || node.decorators.length >= 3 || hasNewlineBetweenOrAfterDecorators(node, options);
    const decorators = path.map((x) => [print(x), ifBreak(line, " ")], "decorators");
    return {
        decorators: group([shouldBreak ? breakParent : "", decorators]),
        multiline: shouldBreak,
    };
}
/**
 * Check if there is already new lines in between the decorators of the node.
 */
function hasNewlineBetweenOrAfterDecorators(node, options) {
    return node.decorators.some((decorator) => prettier.util.hasNewline(options.originalText, decorator.end));
}
export function printDecorator(path, options, print) {
    const args = printDecoratorArgs(path, options, print);
    return ["@", path.call(print, "target"), args];
}
export function printAugmentDecorator(path, options, print) {
    const args = printAugmentDecoratorArgs(path, options, print);
    return ["@@", path.call(print, "target"), args, ";"];
}
function printAugmentDecoratorArgs(path, options, print) {
    return [
        "(",
        group([
            indent(join(", ", [
                path.call(print, "targetType"),
                ...path.map((arg) => [softline, print(arg)], "arguments"),
            ])),
            softline,
        ]),
        ")",
    ];
}
export function printDirectives(path, options, print) {
    const node = path.getValue();
    if (node.directives === undefined || node.directives.length === 0) {
        return "";
    }
    const directives = path.map((x) => [print(x), line], "directives");
    return group([...directives, breakParent]);
}
export function printDirective(path, options, print) {
    const args = printDirectiveArgs(path, options, print);
    return ["#", path.call(print, "target"), " ", args];
}
function printDecoratorArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    // So that decorator with single object arguments have ( and { hugging.
    // @deco({
    //   value: "foo"
    // })
    const shouldHug = node.arguments.length === 1 &&
        (node.arguments[0].kind === SyntaxKind.ModelExpression ||
            node.arguments[0].kind === SyntaxKind.StringLiteral);
    if (shouldHug) {
        return [
            "(",
            join(", ", path.map((arg) => [print(arg)], "arguments")),
            ")",
        ];
    }
    return [
        "(",
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "arguments"))),
            softline,
        ]),
        ")",
    ];
}
export function printDirectiveArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    return join(" ", path.map((arg) => [print(arg)], "arguments"));
}
export function printEnumStatement(path, options, print) {
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const id = path.call(print, "id");
    return [decorators, "enum ", id, " ", printEnumBlock(path, options, print)];
}
function printEnumBlock(path, options, print) {
    const node = path.getValue();
    if (node.members.length === 0) {
        return "{}";
    }
    return group([
        "{",
        indent([
            hardline,
            join(hardline, path.map((x) => [print(x), ","], "members")),
        ]),
        hardline,
        "}",
    ]);
}
export function printEnumMember(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const value = node.value ? [": ", path.call(print, "value")] : "";
    const { decorators, multiline } = printDecorators(path, options, print, { tryInline: true });
    const propertyIndex = path.stack[path.stack.length - 2];
    const isNotFirst = typeof propertyIndex === "number" && propertyIndex > 0;
    return [multiline && isNotFirst ? hardline : "", decorators, id, value];
}
function printEnumSpreadMember(path, options, print) {
    return ["...", path.call(print, "target")];
}
export function printUnionStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return [decorators, "union ", id, generic, " ", printUnionVariantsBlock(path, options, print)];
}
export function printUnionVariantsBlock(path, options, print) {
    const node = path.getValue();
    if (node.options.length === 0) {
        return "{}";
    }
    return group([
        "{",
        indent([
            hardline,
            join(hardline, path.map((x) => [print(x), ","], "options")),
        ]),
        hardline,
        "}",
    ]);
}
export function printUnionVariant(path, options, print) {
    const id = path.call(print, "id");
    const value = [": ", path.call(print, "value")];
    const { decorators } = printDecorators(path, options, print, { tryInline: true });
    return [decorators, id, value];
}
export function printInterfaceStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const extendList = printInterfaceExtends(path, options, print);
    return [
        decorators,
        "interface ",
        id,
        generic,
        extendList,
        " ",
        printInterfaceMembers(path, options, print),
    ];
}
function printInterfaceExtends(path, options, print) {
    const node = path.getValue();
    if (node.extends.length === 0) {
        return "";
    }
    const keyword = "extends ";
    return [group(indent([line, keyword, indent(join([",", line], path.map(print, "extends")))]))];
}
export function printInterfaceMembers(path, options, print) {
    const node = path.getValue();
    const hasOperations = node.operations.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasOperations && !nodeHasComments) {
        return "{}";
    }
    const lastOperation = node.operations[node.operations.length - 1];
    const parts = [];
    path.each((operationPath) => {
        const node = operationPath.getValue();
        const printed = print(operationPath);
        parts.push(printed);
        if (node !== lastOperation) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, "operations");
    const body = [hardline, parts];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), hardline, "}"]);
}
function printDanglingComments(path, options, { sameIndent }) {
    const node = path.getValue();
    const parts = [];
    if (!node || !node.comments) {
        return "";
    }
    path.each((commentPath) => {
        const comment = commentPath.getValue();
        if (!comment.leading && !comment.trailing) {
            parts.push(printComment(path, options));
        }
    }, "comments");
    if (parts.length === 0) {
        return "";
    }
    if (sameIndent) {
        return join(hardline, parts);
    }
    return indent([hardline, join(hardline, parts)]);
}
/**
 * Handle printing an intersection node.
 * @example `Foo & Bar` or `{foo: string} & {bar: string}`
 *
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier child print callback.
 * @returns Prettier document.
 */
export function printIntersection(path, options, print) {
    const node = path.getValue();
    const types = path.map(print, "options");
    const result = [];
    let wasIndented = false;
    for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
            result.push(types[i]);
        }
        else if (isModelNode(node.options[i - 1]) && isModelNode(node.options[i])) {
            // If both are objects, don't indent
            result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
        }
        else if (!isModelNode(node.options[i - 1]) && !isModelNode(node.options[i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent([" &", line, types[i]]));
        }
        else {
            // If you go from object to non-object or vis-versa, then inline it
            if (i > 1) {
                wasIndented = true;
            }
            result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
    }
    return group(result);
}
function isModelNode(node) {
    return node.kind === SyntaxKind.ModelExpression;
}
export function printArray(path, options, print) {
    return [path.call(print, "elementType"), "[]"];
}
export function printTuple(path, options, print) {
    return group([
        "[",
        indent(join(", ", path.map((arg) => [softline, print(arg)], "values"))),
        softline,
        "]",
    ]);
}
export function printMemberExpression(path, options, print) {
    const node = path.getValue();
    return [node.base ? [path.call(print, "base"), "."] : "", path.call(print, "id")];
}
export function printModelExpression(path, options, print) {
    const inBlock = isModelExpressionInBlock(path);
    if (inBlock) {
        return group(printModelPropertiesBlock(path, options, print));
    }
    else {
        return group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "properties"))),
            softline,
        ]);
    }
}
export function printModelStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    const isBase = node.is ? [ifBreak(line, " "), "is ", path.call(print, "is")] : "";
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const shouldPrintBody = nodeHasComments || !(node.properties.length === 0 && node.is);
    const body = shouldPrintBody ? [" ", printModelPropertiesBlock(path, options, print)] : ";";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "model ",
        id,
        generic,
        group(indent(["", heritage, isBase])),
        body,
    ];
}
function printModelPropertiesBlock(path, options, print) {
    var _a;
    const node = path.getValue();
    const hasProperties = node.properties && node.properties.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "{}";
    }
    const tryInline = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.TemplateParameterDeclaration;
    const lineDoc = tryInline ? softline : hardline;
    const seperator = isModelAValue(path) ? "," : ";";
    const body = [
        lineDoc,
        join([seperator, lineDoc], path.map((x) => [print(x)], "properties")),
        hasProperties ? ifBreak(seperator) : "",
    ];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), lineDoc, "}"]);
}
/**
 * Figure out if this model is being used as a definition or value.
 * @returns true if the model is used as a value(e.g. decorator value), false if it is used as a model definition.
 */
function isModelAValue(path) {
    let count = 0;
    let node = path.getValue();
    do {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.AliasStatement:
            case SyntaxKind.OperationStatement:
                return false;
            case SyntaxKind.DecoratorExpression:
                return true;
        }
    } while ((node = path.getParentNode(count++)));
    return true;
}
export function printModelProperty(path, options, print) {
    const node = path.getValue();
    const propertyIndex = path.stack[path.stack.length - 2];
    const isNotFirst = typeof propertyIndex === "number" && propertyIndex > 0;
    const { decorators, multiline } = printDecorators(path, options, print, {
        tryInline: true,
    });
    const id = printIdentifier(node.id, options);
    return [
        multiline && isNotFirst ? hardline : "",
        printDirectives(path, options, print),
        decorators,
        id,
        node.optional ? "?: " : ": ",
        path.call(print, "value"),
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printIdentifier(id, options) {
    return printId(id.sv);
}
export function printId(sv) {
    if (needBacktick(sv)) {
        const escapedString = sv
            .replace(/\\/g, "\\\\")
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r")
            .replace(/\t/g, "\\t")
            .replace(/`/g, "\\`");
        return `\`${escapedString}\``;
    }
    else {
        return sv;
    }
}
function needBacktick(sv) {
    if (sv.length === 0) {
        return false;
    }
    if (Keywords.has(sv)) {
        return true;
    }
    let cp = sv.codePointAt(0);
    if (!isIdentifierStart(cp)) {
        return true;
    }
    let pos = 0;
    do {
        pos += utf16CodeUnits(cp);
    } while (pos < sv.length && isIdentifierContinue((cp = sv.codePointAt(pos))));
    return pos < sv.length;
}
function isModelExpressionInBlock(path) {
    const parent = path.getParentNode();
    switch (parent === null || parent === void 0 ? void 0 : parent.kind) {
        case SyntaxKind.OperationSignatureDeclaration:
            return parent.parameters !== path.getNode();
        default:
            return true;
    }
}
export function printScalarStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "scalar ",
        id,
        template,
        group(indent(["", heritage])),
        ";",
    ];
}
export function printNamespaceStatement(path, options, print) {
    const printNested = (currentPath, parentNames) => {
        var _a;
        const names = [...parentNames, currentPath.call(print, "id")];
        const currentNode = currentPath.getNode();
        if (!isArray(currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) &&
            ((_a = currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamespaceStatement) {
            return path.call((x) => printNested(x, names), "statements");
        }
        const suffix = (currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === undefined
            ? ";"
            : [
                " {",
                indent([hardline, printStatementSequence(path, options, print, "statements")]),
                hardline,
                "}",
            ];
        const { decorators } = printDecorators(path, options, print, { tryInline: false });
        return [decorators, `namespace `, join(".", names), suffix];
    };
    return printNested(path, []);
}
export function printOperationSignatureDeclaration(path, options, print) {
    return ["(", path.call(print, "parameters"), "): ", path.call(print, "returnType")];
}
export function printOperationSignatureReference(path, options, print) {
    return [" is ", path.call(print, "baseOperation")];
}
export function printOperationStatement(path, options, print) {
    var _a;
    const inInterface = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement;
    const templateParams = printTemplateParameters(path, options, print, "templateParameters");
    const { decorators } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return [
        decorators,
        inInterface ? "" : "op ",
        path.call(print, "id"),
        templateParams,
        path.call(print, "signature"),
        `;`,
    ];
}
export function printStatementSequence(path, options, print, property) {
    const node = path.getValue();
    const parts = [];
    const lastStatement = getLastStatement(node[property]);
    path.each((statementPath) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        if (node !== lastStatement) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, property);
    return parts;
}
function getLastStatement(statements) {
    for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.kind !== SyntaxKind.EmptyStatement) {
            return statement;
        }
    }
    return undefined;
}
export function printUnion(path, options, print) {
    const node = path.getValue();
    const shouldHug = shouldHugType(node);
    const types = path.map((typePath) => {
        let printedType = print(typePath);
        if (!shouldHug) {
            printedType = align(2, printedType);
        }
        return printedType;
    }, "options");
    if (shouldHug) {
        return join(" | ", types);
    }
    const shouldAddStartLine = true;
    const code = [ifBreak([shouldAddStartLine ? line : "", "| "], ""), join([line, "| "], types)];
    return group(indent(code));
}
function shouldHugType(node) {
    if (node.kind === SyntaxKind.UnionExpression || node.kind === SyntaxKind.IntersectionExpression) {
        return node.options.length < 4;
    }
    return false;
}
export function printTypeReference(path, options, print) {
    const type = path.call(print, "target");
    const template = printTemplateParameters(path, options, print, "arguments");
    return [type, template];
}
function printTemplateParameterDeclaration(path, options, print) {
    const node = path.getValue();
    return [
        path.call(print, "id"),
        node.constraint ? [" extends ", path.call(print, "constraint")] : "",
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printModelSpread(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printDecoratorDeclarationStatement(path, options, print) {
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", [
                [softline, path.call(print, "target")],
                ...path.map((arg) => [softline, print(arg)], "parameters"),
            ])),
            softline,
        ]),
    ];
    return [printModifiers(path, options, print), "dec ", id, "(", parameters, ")", ";"];
}
function printFunctionDeclarationStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const parameters = [
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "parameters"))),
            softline,
        ]),
    ];
    const returnType = node.returnType ? [": ", path.call(print, "returnType")] : "";
    return [printModifiers(path, options, print), "fn ", id, "(", parameters, ")", returnType, ";"];
}
function printFunctionParameterDeclaration(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const type = node.type ? [": ", path.call(print, "type")] : "";
    return [
        node.rest ? "..." : "",
        printDirectives(path, options, print),
        id,
        node.optional ? "?" : "",
        type,
    ];
}
export function printModifiers(path, options, print) {
    const node = path.getValue();
    if (node.modifiers.length === 0) {
        return "";
    }
    return path.map((x) => [print(x), " "], "modifiers");
}
function printStringLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printNumberLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printBooleanLiteral(path, options) {
    const node = path.getValue();
    return node.value ? "true" : "false";
}
function printProjectionStatement(path, options, print) {
    const selector = path.call(print, "selector");
    const id = path.call(print, "id");
    const projections = path.map(print, "projections").flatMap((x) => [hardline, x]);
    return [
        "projection ",
        selector,
        "#",
        id,
        " {",
        indent(projections),
        projections.length > 0 ? hardline : "",
        "}",
    ];
}
function printProjection(path, options, print) {
    const node = path.getValue();
    const params = printProjectionParameters(path, options, print);
    const body = printProjectionExpressionStatements(path, options, print, "body");
    return [
        ...node.modifierIds.flatMap((i) => [i.sv, " "]),
        node.directionId.sv,
        params,
        " {",
        indent(body),
        hardline,
        "}",
    ];
}
function printProjectionParameters(path, options, print) {
    const node = path.getValue();
    const params = node.parameters;
    if (params.length === 0) {
        return "";
    }
    const shouldHug = params.length === 1;
    if (shouldHug) {
        return ["(", printItemList(path, options, print, "parameters"), ")"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, "parameters"))]);
        return group(["(", body, softline, ")"]);
    }
}
function printProjectionExpressionStatements(path, options, print, key) {
    const parts = [hardline];
    const lastIndex = path.getValue()[key].length - 1;
    path.each((statementPath, index) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        parts.push(";");
        if (index < lastIndex) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, key);
    return parts;
}
function printProjectionParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
function printProjectionExpressionStatement(path, options, print) {
    return path.call(print, "expr");
}
function printProjectionIfExpressionNode(path, options, print) {
    const node = path.getValue();
    const test = path.call(print, "test");
    const consequent = path.call(print, "consequent");
    const alternate = node.alternate ? [" else ", path.call(print, "alternate")] : "";
    return ["if ", test, " ", consequent, alternate];
}
export function printProjectionBlockExpressionNode(path, options, print) {
    const node = path.getValue();
    if (node.statements.length === 0) {
        return "{}";
    }
    return [
        "{",
        indent(printProjectionExpressionStatements(path, options, print, "statements")),
        hardline,
        "}",
    ];
}
export function printProjectionMemberExpression(path, options, print) {
    const node = path.getValue();
    return [path.call(print, "base"), node.selector, path.call(print, "id")];
}
export function printProjectionLeftRightExpression(path, options, print) {
    const node = path.getValue();
    return [path.call(print, "left"), " ", node.op, " ", path.call(print, "right")];
}
export function printProjectionUnaryExpression(path, options, print) {
    return ["!", path.call(print, "target")];
}
export function printProjectionCallExpression(path, options, print) {
    const node = path.getValue();
    const target = path.call(print, "target");
    const params = printItemList(path, options, print, "arguments");
    if (node.callKind === "method") {
        return [target, "(", params, ")"];
    }
    else {
        return [target, "<", params, ">"];
    }
}
export function printProjectionLambdaExpression(path, options, print) {
    return [
        "(",
        printItemList(path, options, print, "parameters"),
        ")",
        " => ",
        path.call(print, "body"),
    ];
}
export function printProjectionLambdaParameterDeclaration(path, options, print) {
    return path.call(print, "id");
}
export function printReturnExpression(path, options, print) {
    return ["return ", path.call(print, "value")];
}
function printItemList(path, options, print, key) {
    return join(", ", path.map(print, key));
}
/**
 * @param node Node that has postition information.
 * @param options Prettier options
 * @returns Raw text in the file for the given node.
 */
function getRawText(node, options) {
    return options.originalText.slice(node.pos, node.end);
}
function hasComments(node, flags) {
    if (!node.comments || node.comments.length === 0) {
        return false;
    }
    const test = getCommentTestFunction(flags);
    return test ? node.comments.some(test) : true;
}
var CommentCheckFlags;
(function (CommentCheckFlags) {
    /** Check comment is a leading comment */
    CommentCheckFlags[CommentCheckFlags["Leading"] = 2] = "Leading";
    /** Check comment is a trailing comment */
    CommentCheckFlags[CommentCheckFlags["Trailing"] = 4] = "Trailing";
    /** Check comment is a dangling comment */
    CommentCheckFlags[CommentCheckFlags["Dangling"] = 8] = "Dangling";
    /** Check comment is a block comment */
    CommentCheckFlags[CommentCheckFlags["Block"] = 16] = "Block";
    /** Check comment is a line comment */
    CommentCheckFlags[CommentCheckFlags["Line"] = 32] = "Line";
    /** Check comment is a `prettier-ignore` comment */
    CommentCheckFlags[CommentCheckFlags["PrettierIgnore"] = 64] = "PrettierIgnore";
    /** Check comment is the first attached comment */
    CommentCheckFlags[CommentCheckFlags["First"] = 128] = "First";
    /** Check comment is the last attached comment */
    CommentCheckFlags[CommentCheckFlags["Last"] = 256] = "Last";
})(CommentCheckFlags || (CommentCheckFlags = {}));
function getCommentTestFunction(flags) {
    if (flags) {
        return (comment, index, comments) => !((flags & CommentCheckFlags.Leading && !comment.leading) ||
            (flags & CommentCheckFlags.Trailing && !comment.trailing) ||
            (flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing)) ||
            (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||
            (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||
            (flags & CommentCheckFlags.First && index !== 0) ||
            (flags & CommentCheckFlags.Last && index !== comments.length - 1));
    }
    return undefined;
}
function isBlockComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
function isLineComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
//# sourceMappingURL=printer.js.map